{"version":3,"sources":["../src/index.ts","../src/constants.ts","../node_modules/.pnpm/@vue+shared@3.2.47/node_modules/@vue/shared/dist/shared.esm-bundler.js","../node_modules/.pnpm/@vue+reactivity@3.2.47/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js","../src/utils.ts","../src/errorHandling.ts","../src/scheduler.ts","../src/instance.ts","../src/watch.ts","../src/lifetimes.ts","../src/plugin.ts","../src/plugins/share.ts","../src/app.ts","../src/props.ts","../src/diff.ts","../src/bindings.ts","../src/setup.ts","../src/page.ts","../src/component.ts","../src/store/index.ts"],"sourcesContent":["// Public API ------------------------------------------------------------------\n\nexport { CORE_KEY } from './constants'\n\nexport { watch, watchEffect, watchPostEffect, watchSyncEffect } from './watch'\nexport type { WatchEffect, WatchSource, WatchCallback } from './watch'\n\nexport { nextTick } from './scheduler'\n\nexport { getCurrentInstance } from './instance'\nexport type { Instance, AppCustomProperties, PageCustomProperties, ComponentCustomProperties } from './instance'\n\nexport { createApp } from './app'\nexport type { AppOptions } from './app'\n\nexport { registerPlugins, loadPlugin } from './plugin'\nexport type { Plugin, PluginSetup, PluginConfig } from './plugin'\n\nexport { definePage } from './page'\nexport { defineComponent } from './component'\n\nexport { defineStore, storeToRefs } from './store'\nexport {\n  onAppShow,\n  onAppHide,\n  onPageNotFound,\n  onUnhandledRejection,\n  onThemeChange,\n  onError,\n  onLoad,\n  onUnload,\n  onPullDownRefresh,\n  onReachBottom,\n  onAddToFavorites,\n  onTabItemTap,\n  onSaveExitState,\n  onShareAppMessage,\n  onShareTimeline,\n  onPageScroll,\n  onMoved,\n  onDetached,\n  onReady,\n  onShow,\n  onHide,\n  onResize,\n} from './lifetimes'\n\nexport {\n  computed,\n  customRef,\n  isProxy,\n  isReactive,\n  isReadonly,\n  isRef,\n  isShallow,\n  markRaw,\n  reactive,\n  readonly,\n  ref,\n  shallowReactive,\n  shallowReadonly,\n  shallowRef,\n  triggerRef,\n  toRaw,\n  toRef,\n  toRefs,\n  unref,\n  ITERATE_KEY,\n} from '@vue/reactivity'\nexport type {\n  DebuggerEvent,\n  ComputedGetter,\n  ComputedRef,\n  CustomRefFactory,\n  ComputedSetter,\n  Ref,\n  ShallowReactive,\n  ShallowUnwrapRef,\n  ToRef,\n  ToRefs,\n  UnwrapNestedRefs,\n  UnwrapRef,\n} from '@vue/reactivity'\n","export const CORE_KEY = '$$core'\n\nexport const APP_LIFETIMES = [\n  'onShow',\n  'onHide',\n  'onError',\n  'onPageNotFound',\n  'onUnhandledRejection',\n  'onThemeChange',\n] as const\n\nexport const PAGE_LIFETIMES = [\n  'onLoad',\n  'onShow',\n  'onReady',\n  'onHide',\n  'onUnload',\n  'onPullDownRefresh',\n  'onReachBottom',\n  'onShareAppMessage',\n  'onShareTimeline',\n  'onAddToFavorites',\n  'onPageScroll',\n  'onResize',\n  'onTabItemTap',\n  'onSaveExitState',\n] as const\n\nexport const COMPONENT_LIFETIMES = {\n  LIFETIMES: ['attached', 'ready', 'moved', 'detached', 'error'],\n  PAGELIFETIMES: ['show', 'hide', 'resize'],\n} as const\n","/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nfunction makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(',');\n    for (let i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\n\n/**\n * dev only flag -> name mapping\n */\nconst PatchFlagNames = {\n    [1 /* PatchFlags.TEXT */]: `TEXT`,\n    [2 /* PatchFlags.CLASS */]: `CLASS`,\n    [4 /* PatchFlags.STYLE */]: `STYLE`,\n    [8 /* PatchFlags.PROPS */]: `PROPS`,\n    [16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,\n    [32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\n    [64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\n    [128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\n    [256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\n    [512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,\n    [1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\n    [2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\n    [-1 /* PatchFlags.HOISTED */]: `HOISTED`,\n    [-2 /* PatchFlags.BAIL */]: `BAIL`\n};\n\n/**\n * Dev only\n */\nconst slotFlagsText = {\n    [1 /* SlotFlags.STABLE */]: 'STABLE',\n    [2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',\n    [3 /* SlotFlags.FORWARDED */]: 'FORWARDED'\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n    // Split the content into individual lines but capture the newline sequence\n    // that separated each line. This is important because the actual sequence is\n    // needed to properly take into account the full line length for offset\n    // comparison\n    let lines = source.split(/(\\r?\\n)/);\n    // Separate the lines and newline sequences into separate arrays for easier referencing\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n    lines = lines.filter((_, idx) => idx % 2 === 0);\n    let count = 0;\n    const res = [];\n    for (let i = 0; i < lines.length; i++) {\n        count +=\n            lines[i].length +\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\n        if (count >= start) {\n            for (let j = i - range; j <= i + range || end > count; j++) {\n                if (j < 0 || j >= lines.length)\n                    continue;\n                const line = j + 1;\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n                const lineLength = lines[j].length;\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\n                if (j === i) {\n                    // push underline\n                    const pad = start - (count - (lineLength + newLineSeqLength));\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\n                }\n                else if (j > i) {\n                    if (end > count) {\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\n                        res.push(`   |  ` + '^'.repeat(length));\n                    }\n                    count += lineLength + newLineSeqLength;\n                }\n            }\n            break;\n        }\n    }\n    return res.join('\\n');\n}\n\nfunction normalizeStyle(value) {\n    if (isArray(value)) {\n        const res = {};\n        for (let i = 0; i < value.length; i++) {\n            const item = value[i];\n            const normalized = isString(item)\n                ? parseStringStyle(item)\n                : normalizeStyle(item);\n            if (normalized) {\n                for (const key in normalized) {\n                    res[key] = normalized[key];\n                }\n            }\n        }\n        return res;\n    }\n    else if (isString(value)) {\n        return value;\n    }\n    else if (isObject(value)) {\n        return value;\n    }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*.*?\\*\\//gs;\nfunction parseStringStyle(cssText) {\n    const ret = {};\n    cssText\n        .replace(styleCommentRE, '')\n        .split(listDelimiterRE)\n        .forEach(item => {\n        if (item) {\n            const tmp = item.split(propertyDelimiterRE);\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n        }\n    });\n    return ret;\n}\nfunction stringifyStyle(styles) {\n    let ret = '';\n    if (!styles || isString(styles)) {\n        return ret;\n    }\n    for (const key in styles) {\n        const value = styles[key];\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n        if (isString(value) || typeof value === 'number') {\n            // only render valid values\n            ret += `${normalizedKey}:${value};`;\n        }\n    }\n    return ret;\n}\nfunction normalizeClass(value) {\n    let res = '';\n    if (isString(value)) {\n        res = value;\n    }\n    else if (isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n            const normalized = normalizeClass(value[i]);\n            if (normalized) {\n                res += normalized + ' ';\n            }\n        }\n    }\n    else if (isObject(value)) {\n        for (const name in value) {\n            if (value[name]) {\n                res += name + ' ';\n            }\n        }\n    }\n    return res.trim();\n}\nfunction normalizeProps(props) {\n    if (!props)\n        return null;\n    let { class: klass, style } = props;\n    if (klass && !isString(klass)) {\n        props.class = normalizeClass(klass);\n    }\n    if (style) {\n        props.style = normalizeStyle(style);\n    }\n    return props;\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\n    'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\n    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\n    'option,output,progress,select,textarea,details,dialog,menu,' +\n    'summary,template,blockquote,iframe,tfoot';\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\n    'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\n    'text,textPath,title,tspan,unknown,use,view';\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\n/**\n * On the client we only need to offer special cases for boolean attributes that\n * have different names from their corresponding dom properties:\n * - itemscope -> N/A\n * - allowfullscreen -> allowFullscreen\n * - formnovalidate -> formNoValidate\n * - ismap -> isMap\n * - nomodule -> noModule\n * - novalidate -> noValidate\n * - readonly -> readOnly\n */\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\n/**\n * The full list is needed during SSR to produce the correct initial markup.\n */\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\n    `loop,open,required,reversed,scoped,seamless,` +\n    `checked,muted,multiple,selected`);\n/**\n * Boolean attributes should be included if the value is truthy or ''.\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\n */\nfunction includeBooleanAttr(value) {\n    return !!value || value === '';\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n    if (attrValidationCache.hasOwnProperty(name)) {\n        return attrValidationCache[name];\n    }\n    const isUnsafe = unsafeAttrCharRE.test(name);\n    if (isUnsafe) {\n        console.error(`unsafe attribute name: ${name}`);\n    }\n    return (attrValidationCache[name] = !isUnsafe);\n}\nconst propsToAttrMap = {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n};\n/**\n * Known attributes, this is used for stringification of runtime static nodes\n * so that we don't stringify bindings that cannot be set from HTML.\n * Don't also forget to allow `data-*` and `aria-*`!\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n */\nconst isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\n    `value,width,wrap`);\n/**\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\n */\nconst isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\n    `color-interpolation-filters,color-profile,color-rendering,` +\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n    const str = '' + string;\n    const match = escapeRE.exec(str);\n    if (!match) {\n        return str;\n    }\n    let html = '';\n    let escaped;\n    let index;\n    let lastIndex = 0;\n    for (index = match.index; index < str.length; index++) {\n        switch (str.charCodeAt(index)) {\n            case 34: // \"\n                escaped = '&quot;';\n                break;\n            case 38: // &\n                escaped = '&amp;';\n                break;\n            case 39: // '\n                escaped = '&#39;';\n                break;\n            case 60: // <\n                escaped = '&lt;';\n                break;\n            case 62: // >\n                escaped = '&gt;';\n                break;\n            default:\n                continue;\n        }\n        if (lastIndex !== index) {\n            html += str.slice(lastIndex, index);\n        }\n        lastIndex = index + 1;\n        html += escaped;\n    }\n    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\n// https://www.w3.org/TR/html52/syntax.html#comments\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n    return src.replace(commentStripRE, '');\n}\n\nfunction looseCompareArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let equal = true;\n    for (let i = 0; equal && i < a.length; i++) {\n        equal = looseEqual(a[i], b[i]);\n    }\n    return equal;\n}\nfunction looseEqual(a, b) {\n    if (a === b)\n        return true;\n    let aValidType = isDate(a);\n    let bValidType = isDate(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n    }\n    aValidType = isSymbol(a);\n    bValidType = isSymbol(b);\n    if (aValidType || bValidType) {\n        return a === b;\n    }\n    aValidType = isArray(a);\n    bValidType = isArray(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n    }\n    aValidType = isObject(a);\n    bValidType = isObject(b);\n    if (aValidType || bValidType) {\n        /* istanbul ignore if: this if will probably never be called */\n        if (!aValidType || !bValidType) {\n            return false;\n        }\n        const aKeysCount = Object.keys(a).length;\n        const bKeysCount = Object.keys(b).length;\n        if (aKeysCount !== bKeysCount) {\n            return false;\n        }\n        for (const key in a) {\n            const aHasKey = a.hasOwnProperty(key);\n            const bHasKey = b.hasOwnProperty(key);\n            if ((aHasKey && !bHasKey) ||\n                (!aHasKey && bHasKey) ||\n                !looseEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n    }\n    return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n    return arr.findIndex(item => looseEqual(item, val));\n}\n\n/**\n * For converting {{ interpolation }} values to displayed strings.\n * @private\n */\nconst toDisplayString = (val) => {\n    return isString(val)\n        ? val\n        : val == null\n            ? ''\n            : isArray(val) ||\n                (isObject(val) &&\n                    (val.toString === objectToString || !isFunction(val.toString)))\n                ? JSON.stringify(val, replacer, 2)\n                : String(val);\n};\nconst replacer = (_key, val) => {\n    // can't use isRef here since @vue/shared has no deps\n    if (val && val.__v_isRef) {\n        return replacer(_key, val.value);\n    }\n    else if (isMap(val)) {\n        return {\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\n                entries[`${key} =>`] = val;\n                return entries;\n            }, {})\n        };\n    }\n    else if (isSet(val)) {\n        return {\n            [`Set(${val.size})`]: [...val.values()]\n        };\n    }\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n        return String(val);\n    }\n    return val;\n};\n\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\n    ? Object.freeze({})\n    : {};\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\nconst NOOP = () => { };\n/**\n * Always return false.\n */\nconst NO = () => false;\nconst onRE = /^on[^a-z]/;\nconst isOn = (key) => onRE.test(key);\nconst isModelListener = (key) => key.startsWith('onUpdate:');\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n    const i = arr.indexOf(el);\n    if (i > -1) {\n        arr.splice(i, 1);\n    }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === '[object Map]';\nconst isSet = (val) => toTypeString(val) === '[object Set]';\nconst isDate = (val) => toTypeString(val) === '[object Date]';\nconst isRegExp = (val) => toTypeString(val) === '[object RegExp]';\nconst isFunction = (val) => typeof val === 'function';\nconst isString = (val) => typeof val === 'string';\nconst isSymbol = (val) => typeof val === 'symbol';\nconst isObject = (val) => val !== null && typeof val === 'object';\nconst isPromise = (val) => {\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n    // extract \"RawType\" from strings like \"[object RawType]\"\n    return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\nconst isIntegerKey = (key) => isString(key) &&\n    key !== 'NaN' &&\n    key[0] !== '-' &&\n    '' + parseInt(key, 10) === key;\nconst isReservedProp = /*#__PURE__*/ makeMap(\n// the leading comma is intentional so empty string \"\" is also included\n',key,ref,ref_for,ref_key,' +\n    'onVnodeBeforeMount,onVnodeMounted,' +\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\nconst isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');\nconst cacheStringFunction = (fn) => {\n    const cache = Object.create(null);\n    return ((str) => {\n        const hit = cache[str];\n        return hit || (cache[str] = fn(str));\n    });\n};\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n */\nconst camelize = cacheStringFunction((str) => {\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\n});\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\n/**\n * @private\n */\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\n/**\n * @private\n */\nconst toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\n// compare whether a value has changed, accounting for NaN.\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n    for (let i = 0; i < fns.length; i++) {\n        fns[i](arg);\n    }\n};\nconst def = (obj, key, value) => {\n    Object.defineProperty(obj, key, {\n        configurable: true,\n        enumerable: false,\n        value\n    });\n};\n/**\n * \"123-foo\" will be parsed to 123\n * This is used for the .number modifier in v-model\n */\nconst looseToNumber = (val) => {\n    const n = parseFloat(val);\n    return isNaN(n) ? val : n;\n};\n/**\n * Only conerces number-like strings\n * \"123-foo\" will be returned as-is\n */\nconst toNumber = (val) => {\n    const n = isString(val) ? Number(val) : NaN;\n    return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n    return (_globalThis ||\n        (_globalThis =\n            typeof globalThis !== 'undefined'\n                ? globalThis\n                : typeof self !== 'undefined'\n                    ? self\n                    : typeof window !== 'undefined'\n                        ? window\n                        : typeof global !== 'undefined'\n                            ? global\n                            : {}));\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n    return identRE.test(name)\n        ? `__props.${name}`\n        : `__props[${JSON.stringify(name)}]`;\n}\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, camelize, capitalize, def, escapeHtml, escapeHtmlComment, extend, genPropsAccessExp, generateCodeFrame, getGlobalThis, hasChanged, hasOwn, hyphenate, includeBooleanAttr, invokeArrayFns, isArray, isBooleanAttr, isBuiltInDirective, isDate, isFunction, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownHtmlAttr, isKnownSvgAttr, isMap, isModelListener, isObject, isOn, isPlainObject, isPromise, isRegExp, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, looseToNumber, makeMap, normalizeClass, normalizeProps, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n","import { extend, isArray, isMap, isIntegerKey, hasOwn, isSymbol, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n    console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n    constructor(detached = false) {\n        this.detached = detached;\n        /**\n         * @internal\n         */\n        this._active = true;\n        /**\n         * @internal\n         */\n        this.effects = [];\n        /**\n         * @internal\n         */\n        this.cleanups = [];\n        this.parent = activeEffectScope;\n        if (!detached && activeEffectScope) {\n            this.index =\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n        }\n    }\n    get active() {\n        return this._active;\n    }\n    run(fn) {\n        if (this._active) {\n            const currentEffectScope = activeEffectScope;\n            try {\n                activeEffectScope = this;\n                return fn();\n            }\n            finally {\n                activeEffectScope = currentEffectScope;\n            }\n        }\n        else if ((process.env.NODE_ENV !== 'production')) {\n            warn(`cannot run an inactive effect scope.`);\n        }\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    on() {\n        activeEffectScope = this;\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    off() {\n        activeEffectScope = this.parent;\n    }\n    stop(fromParent) {\n        if (this._active) {\n            let i, l;\n            for (i = 0, l = this.effects.length; i < l; i++) {\n                this.effects[i].stop();\n            }\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\n                this.cleanups[i]();\n            }\n            if (this.scopes) {\n                for (i = 0, l = this.scopes.length; i < l; i++) {\n                    this.scopes[i].stop(true);\n                }\n            }\n            // nested scope, dereference from parent to avoid memory leaks\n            if (!this.detached && this.parent && !fromParent) {\n                // optimized O(1) removal\n                const last = this.parent.scopes.pop();\n                if (last && last !== this) {\n                    this.parent.scopes[this.index] = last;\n                    last.index = this.index;\n                }\n            }\n            this.parent = undefined;\n            this._active = false;\n        }\n    }\n}\nfunction effectScope(detached) {\n    return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n    if (scope && scope.active) {\n        scope.effects.push(effect);\n    }\n}\nfunction getCurrentScope() {\n    return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n    if (activeEffectScope) {\n        activeEffectScope.cleanups.push(fn);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        warn(`onScopeDispose() is called when there is no active effect scope` +\n            ` to be associated with.`);\n    }\n}\n\nconst createDep = (effects) => {\n    const dep = new Set(effects);\n    dep.w = 0;\n    dep.n = 0;\n    return dep;\n};\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = ({ deps }) => {\n    if (deps.length) {\n        for (let i = 0; i < deps.length; i++) {\n            deps[i].w |= trackOpBit; // set was tracked\n        }\n    }\n};\nconst finalizeDepMarkers = (effect) => {\n    const { deps } = effect;\n    if (deps.length) {\n        let ptr = 0;\n        for (let i = 0; i < deps.length; i++) {\n            const dep = deps[i];\n            if (wasTracked(dep) && !newTracked(dep)) {\n                dep.delete(effect);\n            }\n            else {\n                deps[ptr++] = dep;\n            }\n            // clear bits\n            dep.w &= ~trackOpBit;\n            dep.n &= ~trackOpBit;\n        }\n        deps.length = ptr;\n    }\n};\n\nconst targetMap = new WeakMap();\n// The number of effects currently being tracked recursively.\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\n/**\n * The bitwise track markers support at most 30 levels of recursion.\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\n * When recursion depth is greater, fall back to using a full cleanup.\n */\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\nclass ReactiveEffect {\n    constructor(fn, scheduler = null, scope) {\n        this.fn = fn;\n        this.scheduler = scheduler;\n        this.active = true;\n        this.deps = [];\n        this.parent = undefined;\n        recordEffectScope(this, scope);\n    }\n    run() {\n        if (!this.active) {\n            return this.fn();\n        }\n        let parent = activeEffect;\n        let lastShouldTrack = shouldTrack;\n        while (parent) {\n            if (parent === this) {\n                return;\n            }\n            parent = parent.parent;\n        }\n        try {\n            this.parent = activeEffect;\n            activeEffect = this;\n            shouldTrack = true;\n            trackOpBit = 1 << ++effectTrackDepth;\n            if (effectTrackDepth <= maxMarkerBits) {\n                initDepMarkers(this);\n            }\n            else {\n                cleanupEffect(this);\n            }\n            return this.fn();\n        }\n        finally {\n            if (effectTrackDepth <= maxMarkerBits) {\n                finalizeDepMarkers(this);\n            }\n            trackOpBit = 1 << --effectTrackDepth;\n            activeEffect = this.parent;\n            shouldTrack = lastShouldTrack;\n            this.parent = undefined;\n            if (this.deferStop) {\n                this.stop();\n            }\n        }\n    }\n    stop() {\n        // stopped while running itself - defer the cleanup\n        if (activeEffect === this) {\n            this.deferStop = true;\n        }\n        else if (this.active) {\n            cleanupEffect(this);\n            if (this.onStop) {\n                this.onStop();\n            }\n            this.active = false;\n        }\n    }\n}\nfunction cleanupEffect(effect) {\n    const { deps } = effect;\n    if (deps.length) {\n        for (let i = 0; i < deps.length; i++) {\n            deps[i].delete(effect);\n        }\n        deps.length = 0;\n    }\n}\nfunction effect(fn, options) {\n    if (fn.effect) {\n        fn = fn.effect.fn;\n    }\n    const _effect = new ReactiveEffect(fn);\n    if (options) {\n        extend(_effect, options);\n        if (options.scope)\n            recordEffectScope(_effect, options.scope);\n    }\n    if (!options || !options.lazy) {\n        _effect.run();\n    }\n    const runner = _effect.run.bind(_effect);\n    runner.effect = _effect;\n    return runner;\n}\nfunction stop(runner) {\n    runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = false;\n}\nfunction enableTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = true;\n}\nfunction resetTracking() {\n    const last = trackStack.pop();\n    shouldTrack = last === undefined ? true : last;\n}\nfunction track(target, type, key) {\n    if (shouldTrack && activeEffect) {\n        let depsMap = targetMap.get(target);\n        if (!depsMap) {\n            targetMap.set(target, (depsMap = new Map()));\n        }\n        let dep = depsMap.get(key);\n        if (!dep) {\n            depsMap.set(key, (dep = createDep()));\n        }\n        const eventInfo = (process.env.NODE_ENV !== 'production')\n            ? { effect: activeEffect, target, type, key }\n            : undefined;\n        trackEffects(dep, eventInfo);\n    }\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n    let shouldTrack = false;\n    if (effectTrackDepth <= maxMarkerBits) {\n        if (!newTracked(dep)) {\n            dep.n |= trackOpBit; // set newly tracked\n            shouldTrack = !wasTracked(dep);\n        }\n    }\n    else {\n        // Full cleanup mode.\n        shouldTrack = !dep.has(activeEffect);\n    }\n    if (shouldTrack) {\n        dep.add(activeEffect);\n        activeEffect.deps.push(dep);\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.onTrack) {\n            activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));\n        }\n    }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {\n        // never been tracked\n        return;\n    }\n    let deps = [];\n    if (type === \"clear\" /* TriggerOpTypes.CLEAR */) {\n        // collection being cleared\n        // trigger all effects for target\n        deps = [...depsMap.values()];\n    }\n    else if (key === 'length' && isArray(target)) {\n        const newLength = Number(newValue);\n        depsMap.forEach((dep, key) => {\n            if (key === 'length' || key >= newLength) {\n                deps.push(dep);\n            }\n        });\n    }\n    else {\n        // schedule runs for SET | ADD | DELETE\n        if (key !== void 0) {\n            deps.push(depsMap.get(key));\n        }\n        // also run for iteration key on ADD | DELETE | Map.SET\n        switch (type) {\n            case \"add\" /* TriggerOpTypes.ADD */:\n                if (!isArray(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                    if (isMap(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n                    }\n                }\n                else if (isIntegerKey(key)) {\n                    // new index added to array -> length changes\n                    deps.push(depsMap.get('length'));\n                }\n                break;\n            case \"delete\" /* TriggerOpTypes.DELETE */:\n                if (!isArray(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                    if (isMap(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n                    }\n                }\n                break;\n            case \"set\" /* TriggerOpTypes.SET */:\n                if (isMap(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                }\n                break;\n        }\n    }\n    const eventInfo = (process.env.NODE_ENV !== 'production')\n        ? { target, type, key, newValue, oldValue, oldTarget }\n        : undefined;\n    if (deps.length === 1) {\n        if (deps[0]) {\n            if ((process.env.NODE_ENV !== 'production')) {\n                triggerEffects(deps[0], eventInfo);\n            }\n            else {\n                triggerEffects(deps[0]);\n            }\n        }\n    }\n    else {\n        const effects = [];\n        for (const dep of deps) {\n            if (dep) {\n                effects.push(...dep);\n            }\n        }\n        if ((process.env.NODE_ENV !== 'production')) {\n            triggerEffects(createDep(effects), eventInfo);\n        }\n        else {\n            triggerEffects(createDep(effects));\n        }\n    }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n    // spread into array for stabilization\n    const effects = isArray(dep) ? dep : [...dep];\n    for (const effect of effects) {\n        if (effect.computed) {\n            triggerEffect(effect, debuggerEventExtraInfo);\n        }\n    }\n    for (const effect of effects) {\n        if (!effect.computed) {\n            triggerEffect(effect, debuggerEventExtraInfo);\n        }\n    }\n}\nfunction triggerEffect(effect, debuggerEventExtraInfo) {\n    if (effect !== activeEffect || effect.allowRecurse) {\n        if ((process.env.NODE_ENV !== 'production') && effect.onTrigger) {\n            effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));\n        }\n        if (effect.scheduler) {\n            effect.scheduler();\n        }\n        else {\n            effect.run();\n        }\n    }\n}\nfunction getDepFromReactive(object, key) {\n    var _a;\n    return (_a = targetMap.get(object)) === null || _a === void 0 ? void 0 : _a.get(key);\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n/*#__PURE__*/\nObject.getOwnPropertyNames(Symbol)\n    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\n    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode\n    // function\n    .filter(key => key !== 'arguments' && key !== 'caller')\n    .map(key => Symbol[key])\n    .filter(isSymbol));\nconst get$1 = /*#__PURE__*/ createGetter();\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n    const instrumentations = {};\n    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\n        instrumentations[key] = function (...args) {\n            const arr = toRaw(this);\n            for (let i = 0, l = this.length; i < l; i++) {\n                track(arr, \"get\" /* TrackOpTypes.GET */, i + '');\n            }\n            // we run the method using the original args first (which may be reactive)\n            const res = arr[key](...args);\n            if (res === -1 || res === false) {\n                // if that didn't work, run it again using raw values.\n                return arr[key](...args.map(toRaw));\n            }\n            else {\n                return res;\n            }\n        };\n    });\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\n        instrumentations[key] = function (...args) {\n            pauseTracking();\n            const res = toRaw(this)[key].apply(this, args);\n            resetTracking();\n            return res;\n        };\n    });\n    return instrumentations;\n}\nfunction hasOwnProperty(key) {\n    const obj = toRaw(this);\n    track(obj, \"has\" /* TrackOpTypes.HAS */, key);\n    return obj.hasOwnProperty(key);\n}\nfunction createGetter(isReadonly = false, shallow = false) {\n    return function get(target, key, receiver) {\n        if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\n            return !isReadonly;\n        }\n        else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\n            return isReadonly;\n        }\n        else if (key === \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */) {\n            return shallow;\n        }\n        else if (key === \"__v_raw\" /* ReactiveFlags.RAW */ &&\n            receiver ===\n                (isReadonly\n                    ? shallow\n                        ? shallowReadonlyMap\n                        : readonlyMap\n                    : shallow\n                        ? shallowReactiveMap\n                        : reactiveMap).get(target)) {\n            return target;\n        }\n        const targetIsArray = isArray(target);\n        if (!isReadonly) {\n            if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n                return Reflect.get(arrayInstrumentations, key, receiver);\n            }\n            if (key === 'hasOwnProperty') {\n                return hasOwnProperty;\n            }\n        }\n        const res = Reflect.get(target, key, receiver);\n        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n            return res;\n        }\n        if (!isReadonly) {\n            track(target, \"get\" /* TrackOpTypes.GET */, key);\n        }\n        if (shallow) {\n            return res;\n        }\n        if (isRef(res)) {\n            // ref unwrapping - skip unwrap for Array + integer key.\n            return targetIsArray && isIntegerKey(key) ? res : res.value;\n        }\n        if (isObject(res)) {\n            // Convert returned value into a proxy as well. we do the isObject check\n            // here to avoid invalid value warning. Also need to lazy access readonly\n            // and reactive here to avoid circular dependency.\n            return isReadonly ? readonly(res) : reactive(res);\n        }\n        return res;\n    };\n}\nconst set$1 = /*#__PURE__*/ createSetter();\nconst shallowSet = /*#__PURE__*/ createSetter(true);\nfunction createSetter(shallow = false) {\n    return function set(target, key, value, receiver) {\n        let oldValue = target[key];\n        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n            return false;\n        }\n        if (!shallow) {\n            if (!isShallow(value) && !isReadonly(value)) {\n                oldValue = toRaw(oldValue);\n                value = toRaw(value);\n            }\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n                oldValue.value = value;\n                return true;\n            }\n        }\n        const hadKey = isArray(target) && isIntegerKey(key)\n            ? Number(key) < target.length\n            : hasOwn(target, key);\n        const result = Reflect.set(target, key, value, receiver);\n        // don't trigger if target is something up in the prototype chain of original\n        if (target === toRaw(receiver)) {\n            if (!hadKey) {\n                trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\n            }\n            else if (hasChanged(value, oldValue)) {\n                trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\n            }\n        }\n        return result;\n    };\n}\nfunction deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n        trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n    }\n    return result;\n}\nfunction has$1(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n        track(target, \"has\" /* TrackOpTypes.HAS */, key);\n    }\n    return result;\n}\nfunction ownKeys(target) {\n    track(target, \"iterate\" /* TrackOpTypes.ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\n    return Reflect.ownKeys(target);\n}\nconst mutableHandlers = {\n    get: get$1,\n    set: set$1,\n    deleteProperty,\n    has: has$1,\n    ownKeys\n};\nconst readonlyHandlers = {\n    get: readonlyGet,\n    set(target, key) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n        }\n        return true;\n    },\n    deleteProperty(target, key) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n        }\n        return true;\n    }\n};\nconst shallowReactiveHandlers = /*#__PURE__*/ extend({}, mutableHandlers, {\n    get: shallowGet,\n    set: shallowSet\n});\n// Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\nconst shallowReadonlyHandlers = /*#__PURE__*/ extend({}, readonlyHandlers, {\n    get: shallowReadonlyGet\n});\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\n    // of the value\n    target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\n    const rawTarget = toRaw(target);\n    const rawKey = toRaw(key);\n    if (!isReadonly) {\n        if (key !== rawKey) {\n            track(rawTarget, \"get\" /* TrackOpTypes.GET */, key);\n        }\n        track(rawTarget, \"get\" /* TrackOpTypes.GET */, rawKey);\n    }\n    const { has } = getProto(rawTarget);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n    }\n    else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n    }\n    else if (target !== rawTarget) {\n        // #3602 readonly(reactive(Map))\n        // ensure that the nested reactive `Map` can do tracking for itself\n        target.get(key);\n    }\n}\nfunction has(key, isReadonly = false) {\n    const target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\n    const rawTarget = toRaw(target);\n    const rawKey = toRaw(key);\n    if (!isReadonly) {\n        if (key !== rawKey) {\n            track(rawTarget, \"has\" /* TrackOpTypes.HAS */, key);\n        }\n        track(rawTarget, \"has\" /* TrackOpTypes.HAS */, rawKey);\n    }\n    return key === rawKey\n        ? target.has(key)\n        : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n    target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\n    !isReadonly && track(toRaw(target), \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n    return Reflect.get(target, 'size', target);\n}\nfunction add(value) {\n    value = toRaw(value);\n    const target = toRaw(this);\n    const proto = getProto(target);\n    const hadKey = proto.has.call(target, value);\n    if (!hadKey) {\n        target.add(value);\n        trigger(target, \"add\" /* TriggerOpTypes.ADD */, value, value);\n    }\n    return this;\n}\nfunction set(key, value) {\n    value = toRaw(value);\n    const target = toRaw(this);\n    const { has, get } = getProto(target);\n    let hadKey = has.call(target, key);\n    if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        checkIdentityKeys(target, has, key);\n    }\n    const oldValue = get.call(target, key);\n    target.set(key, value);\n    if (!hadKey) {\n        trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\n    }\n    else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\n    }\n    return this;\n}\nfunction deleteEntry(key) {\n    const target = toRaw(this);\n    const { has, get } = getProto(target);\n    let hadKey = has.call(target, key);\n    if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        checkIdentityKeys(target, has, key);\n    }\n    const oldValue = get ? get.call(target, key) : undefined;\n    // forward the operation before queueing reactions\n    const result = target.delete(key);\n    if (hadKey) {\n        trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n    }\n    return result;\n}\nfunction clear() {\n    const target = toRaw(this);\n    const hadItems = target.size !== 0;\n    const oldTarget = (process.env.NODE_ENV !== 'production')\n        ? isMap(target)\n            ? new Map(target)\n            : new Set(target)\n        : undefined;\n    // forward the operation before queueing reactions\n    const result = target.clear();\n    if (hadItems) {\n        trigger(target, \"clear\" /* TriggerOpTypes.CLEAR */, undefined, undefined, oldTarget);\n    }\n    return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n    return function forEach(callback, thisArg) {\n        const observed = this;\n        const target = observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n        const rawTarget = toRaw(target);\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n        !isReadonly && track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n        return target.forEach((value, key) => {\n            // important: make sure the callback is\n            // 1. invoked with the reactive map as `this` and 3rd arg\n            // 2. the value received should be a corresponding reactive/readonly.\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\n        });\n    };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n    return function (...args) {\n        const target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\n        const rawTarget = toRaw(target);\n        const targetIsMap = isMap(rawTarget);\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\n        const isKeyOnly = method === 'keys' && targetIsMap;\n        const innerIterator = target[method](...args);\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n        !isReadonly &&\n            track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n        // return a wrapped iterator which returns observed versions of the\n        // values emitted from the real iterator\n        return {\n            // iterator protocol\n            next() {\n                const { value, done } = innerIterator.next();\n                return done\n                    ? { value, done }\n                    : {\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n                        done\n                    };\n            },\n            // iterable protocol\n            [Symbol.iterator]() {\n                return this;\n            }\n        };\n    };\n}\nfunction createReadonlyMethod(type) {\n    return function (...args) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n        }\n        return type === \"delete\" /* TriggerOpTypes.DELETE */ ? false : this;\n    };\n}\nfunction createInstrumentations() {\n    const mutableInstrumentations = {\n        get(key) {\n            return get(this, key);\n        },\n        get size() {\n            return size(this);\n        },\n        has,\n        add,\n        set,\n        delete: deleteEntry,\n        clear,\n        forEach: createForEach(false, false)\n    };\n    const shallowInstrumentations = {\n        get(key) {\n            return get(this, key, false, true);\n        },\n        get size() {\n            return size(this);\n        },\n        has,\n        add,\n        set,\n        delete: deleteEntry,\n        clear,\n        forEach: createForEach(false, true)\n    };\n    const readonlyInstrumentations = {\n        get(key) {\n            return get(this, key, true);\n        },\n        get size() {\n            return size(this, true);\n        },\n        has(key) {\n            return has.call(this, key, true);\n        },\n        add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\n        set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\n        delete: createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\n        clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\n        forEach: createForEach(true, false)\n    };\n    const shallowReadonlyInstrumentations = {\n        get(key) {\n            return get(this, key, true, true);\n        },\n        get size() {\n            return size(this, true);\n        },\n        has(key) {\n            return has.call(this, key, true);\n        },\n        add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\n        set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\n        delete: createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\n        clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\n        forEach: createForEach(true, true)\n    };\n    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\n    iteratorMethods.forEach(method => {\n        mutableInstrumentations[method] = createIterableMethod(method, false, false);\n        readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n        shallowInstrumentations[method] = createIterableMethod(method, false, true);\n        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n    });\n    return [\n        mutableInstrumentations,\n        readonlyInstrumentations,\n        shallowInstrumentations,\n        shallowReadonlyInstrumentations\n    ];\n}\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n    const instrumentations = shallow\n        ? isReadonly\n            ? shallowReadonlyInstrumentations\n            : shallowInstrumentations\n        : isReadonly\n            ? readonlyInstrumentations\n            : mutableInstrumentations;\n    return (target, key, receiver) => {\n        if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\n            return !isReadonly;\n        }\n        else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\n            return isReadonly;\n        }\n        else if (key === \"__v_raw\" /* ReactiveFlags.RAW */) {\n            return target;\n        }\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\n            ? instrumentations\n            : target, key, receiver);\n    };\n}\nconst mutableCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n    const rawKey = toRaw(key);\n    if (rawKey !== key && has.call(target, rawKey)) {\n        const type = toRawType(target);\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\n            `which can lead to inconsistencies. ` +\n            `Avoid differentiating between the raw and reactive versions ` +\n            `of an object and only use the reactive version if possible.`);\n    }\n}\n\nconst reactiveMap = new WeakMap();\nconst shallowReactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\nconst shallowReadonlyMap = new WeakMap();\nfunction targetTypeMap(rawType) {\n    switch (rawType) {\n        case 'Object':\n        case 'Array':\n            return 1 /* TargetType.COMMON */;\n        case 'Map':\n        case 'Set':\n        case 'WeakMap':\n        case 'WeakSet':\n            return 2 /* TargetType.COLLECTION */;\n        default:\n            return 0 /* TargetType.INVALID */;\n    }\n}\nfunction getTargetType(value) {\n    return value[\"__v_skip\" /* ReactiveFlags.SKIP */] || !Object.isExtensible(value)\n        ? 0 /* TargetType.INVALID */\n        : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n    // if trying to observe a readonly proxy, return the readonly version.\n    if (isReadonly(target)) {\n        return target;\n    }\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nfunction shallowReactive(target) {\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\n/**\n * Creates a readonly copy of the original object. Note the returned copy is not\n * made reactive, but `readonly` can be called on an already reactive object.\n */\nfunction readonly(target) {\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nfunction shallowReadonly(target) {\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n    if (!isObject(target)) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(`value cannot be made reactive: ${String(target)}`);\n        }\n        return target;\n    }\n    // target is already a Proxy, return it.\n    // exception: calling readonly() on a reactive object\n    if (target[\"__v_raw\" /* ReactiveFlags.RAW */] &&\n        !(isReadonly && target[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */])) {\n        return target;\n    }\n    // target already has corresponding Proxy\n    const existingProxy = proxyMap.get(target);\n    if (existingProxy) {\n        return existingProxy;\n    }\n    // only specific value types can be observed.\n    const targetType = getTargetType(target);\n    if (targetType === 0 /* TargetType.INVALID */) {\n        return target;\n    }\n    const proxy = new Proxy(target, targetType === 2 /* TargetType.COLLECTION */ ? collectionHandlers : baseHandlers);\n    proxyMap.set(target, proxy);\n    return proxy;\n}\nfunction isReactive(value) {\n    if (isReadonly(value)) {\n        return isReactive(value[\"__v_raw\" /* ReactiveFlags.RAW */]);\n    }\n    return !!(value && value[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */]);\n}\nfunction isReadonly(value) {\n    return !!(value && value[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */]);\n}\nfunction isShallow(value) {\n    return !!(value && value[\"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */]);\n}\nfunction isProxy(value) {\n    return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n    const raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n    return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n    def(value, \"__v_skip\" /* ReactiveFlags.SKIP */, true);\n    return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref) {\n    if (shouldTrack && activeEffect) {\n        ref = toRaw(ref);\n        if ((process.env.NODE_ENV !== 'production')) {\n            trackEffects(ref.dep || (ref.dep = createDep()), {\n                target: ref,\n                type: \"get\" /* TrackOpTypes.GET */,\n                key: 'value'\n            });\n        }\n        else {\n            trackEffects(ref.dep || (ref.dep = createDep()));\n        }\n    }\n}\nfunction triggerRefValue(ref, newVal) {\n    ref = toRaw(ref);\n    const dep = ref.dep;\n    if (dep) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            triggerEffects(dep, {\n                target: ref,\n                type: \"set\" /* TriggerOpTypes.SET */,\n                key: 'value',\n                newValue: newVal\n            });\n        }\n        else {\n            triggerEffects(dep);\n        }\n    }\n}\nfunction isRef(r) {\n    return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n    return createRef(value, false);\n}\nfunction shallowRef(value) {\n    return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n    if (isRef(rawValue)) {\n        return rawValue;\n    }\n    return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n    constructor(value, __v_isShallow) {\n        this.__v_isShallow = __v_isShallow;\n        this.dep = undefined;\n        this.__v_isRef = true;\n        this._rawValue = __v_isShallow ? value : toRaw(value);\n        this._value = __v_isShallow ? value : toReactive(value);\n    }\n    get value() {\n        trackRefValue(this);\n        return this._value;\n    }\n    set value(newVal) {\n        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n        newVal = useDirectValue ? newVal : toRaw(newVal);\n        if (hasChanged(newVal, this._rawValue)) {\n            this._rawValue = newVal;\n            this._value = useDirectValue ? newVal : toReactive(newVal);\n            triggerRefValue(this, newVal);\n        }\n    }\n}\nfunction triggerRef(ref) {\n    triggerRefValue(ref, (process.env.NODE_ENV !== 'production') ? ref.value : void 0);\n}\nfunction unref(ref) {\n    return isRef(ref) ? ref.value : ref;\n}\nconst shallowUnwrapHandlers = {\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n    set: (target, key, value, receiver) => {\n        const oldValue = target[key];\n        if (isRef(oldValue) && !isRef(value)) {\n            oldValue.value = value;\n            return true;\n        }\n        else {\n            return Reflect.set(target, key, value, receiver);\n        }\n    }\n};\nfunction proxyRefs(objectWithRefs) {\n    return isReactive(objectWithRefs)\n        ? objectWithRefs\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n    constructor(factory) {\n        this.dep = undefined;\n        this.__v_isRef = true;\n        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n        this._get = get;\n        this._set = set;\n    }\n    get value() {\n        return this._get();\n    }\n    set value(newVal) {\n        this._set(newVal);\n    }\n}\nfunction customRef(factory) {\n    return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n    if ((process.env.NODE_ENV !== 'production') && !isProxy(object)) {\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\n    }\n    const ret = isArray(object) ? new Array(object.length) : {};\n    for (const key in object) {\n        ret[key] = toRef(object, key);\n    }\n    return ret;\n}\nclass ObjectRefImpl {\n    constructor(_object, _key, _defaultValue) {\n        this._object = _object;\n        this._key = _key;\n        this._defaultValue = _defaultValue;\n        this.__v_isRef = true;\n    }\n    get value() {\n        const val = this._object[this._key];\n        return val === undefined ? this._defaultValue : val;\n    }\n    set value(newVal) {\n        this._object[this._key] = newVal;\n    }\n    get dep() {\n        return getDepFromReactive(toRaw(this._object), this._key);\n    }\n}\nfunction toRef(object, key, defaultValue) {\n    const val = object[key];\n    return isRef(val)\n        ? val\n        : new ObjectRefImpl(object, key, defaultValue);\n}\n\nvar _a$1;\nclass ComputedRefImpl {\n    constructor(getter, _setter, isReadonly, isSSR) {\n        this._setter = _setter;\n        this.dep = undefined;\n        this.__v_isRef = true;\n        this[_a$1] = false;\n        this._dirty = true;\n        this.effect = new ReactiveEffect(getter, () => {\n            if (!this._dirty) {\n                this._dirty = true;\n                triggerRefValue(this);\n            }\n        });\n        this.effect.computed = this;\n        this.effect.active = this._cacheable = !isSSR;\n        this[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */] = isReadonly;\n    }\n    get value() {\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n        const self = toRaw(this);\n        trackRefValue(self);\n        if (self._dirty || !self._cacheable) {\n            self._dirty = false;\n            self._value = self.effect.run();\n        }\n        return self._value;\n    }\n    set value(newValue) {\n        this._setter(newValue);\n    }\n}\n_a$1 = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n    let getter;\n    let setter;\n    const onlyGetter = isFunction(getterOrOptions);\n    if (onlyGetter) {\n        getter = getterOrOptions;\n        setter = (process.env.NODE_ENV !== 'production')\n            ? () => {\n                console.warn('Write operation failed: computed value is readonly');\n            }\n            : NOOP;\n    }\n    else {\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set;\n    }\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n    if ((process.env.NODE_ENV !== 'production') && debugOptions && !isSSR) {\n        cRef.effect.onTrack = debugOptions.onTrack;\n        cRef.effect.onTrigger = debugOptions.onTrigger;\n    }\n    return cRef;\n}\n\nvar _a;\nconst tick = /*#__PURE__*/ Promise.resolve();\nconst queue = [];\nlet queued = false;\nconst scheduler = (fn) => {\n    queue.push(fn);\n    if (!queued) {\n        queued = true;\n        tick.then(flush);\n    }\n};\nconst flush = () => {\n    for (let i = 0; i < queue.length; i++) {\n        queue[i]();\n    }\n    queue.length = 0;\n    queued = false;\n};\nclass DeferredComputedRefImpl {\n    constructor(getter) {\n        this.dep = undefined;\n        this._dirty = true;\n        this.__v_isRef = true;\n        this[_a] = true;\n        let compareTarget;\n        let hasCompareTarget = false;\n        let scheduled = false;\n        this.effect = new ReactiveEffect(getter, (computedTrigger) => {\n            if (this.dep) {\n                if (computedTrigger) {\n                    compareTarget = this._value;\n                    hasCompareTarget = true;\n                }\n                else if (!scheduled) {\n                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n                    scheduled = true;\n                    hasCompareTarget = false;\n                    scheduler(() => {\n                        if (this.effect.active && this._get() !== valueToCompare) {\n                            triggerRefValue(this);\n                        }\n                        scheduled = false;\n                    });\n                }\n                // chained upstream computeds are notified synchronously to ensure\n                // value invalidation in case of sync access; normal effects are\n                // deferred to be triggered in scheduler.\n                for (const e of this.dep) {\n                    if (e.computed instanceof DeferredComputedRefImpl) {\n                        e.scheduler(true /* computedTrigger */);\n                    }\n                }\n            }\n            this._dirty = true;\n        });\n        this.effect.computed = this;\n    }\n    _get() {\n        if (this._dirty) {\n            this._dirty = false;\n            return (this._value = this.effect.run());\n        }\n        return this._value;\n    }\n    get value() {\n        trackRefValue(this);\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n        return toRaw(this)._get();\n    }\n}\n_a = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\nfunction deferredComputed(getter) {\n    return new DeferredComputedRefImpl(getter);\n}\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };\n","import { isRef, type ComputedRef } from '@vue/reactivity'\nimport type { Method } from './types'\n\nexport const EMPTY_OBJ = {}\nexport const NOOP = () => {}\n\nexport const getType = (value: unknown): string => Object.prototype.toString.call(value)\n\nexport const { isArray } = Array\nexport const isFunction = (val: unknown): val is Method => typeof val === 'function'\nexport const isMap = (val: unknown): val is Map<any, any> => getType(val) === '[object Map]'\nexport const isSet = (val: unknown): val is Set<any> => getType(val) === '[object Set]'\nexport const isPlainObject = (val: unknown): val is Record<string, unknown> => {\n  return (val && typeof val === 'object' && getType(val) === '[object Object]') as boolean\n}\nexport const isObject = (val: unknown): val is Record<any, any> =>\n  val !== null && typeof val === 'object'\n\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> =>\n  isObject(val) && isFunction(val.then) && isFunction(val.catch)\n\nexport function isJsonBaseType(x: any): boolean {\n  const simpleTypes = new Set(['boolean', 'number', 'string'])\n  return x === null || simpleTypes.has(typeof x)\n}\n\nexport function isComputed<T>(value: ComputedRef<T> | unknown): value is ComputedRef<T>\nexport function isComputed(o: any): o is ComputedRef {\n  return !!(isRef(o) && (o as any).effect)\n}\n\n// compare whether a value has changed, accounting for NaN.\nexport const hasChanged = (value: any, oldValue: any): boolean => !Object.is(value, oldValue)\n\nexport const remove = <T>(arr: T[], el: T) => {\n  const i = arr.indexOf(el)\n  if (i > -1) {\n    arr.splice(i, 1)\n  }\n  return arr\n}\n\nexport function firstToLower(str: string) {\n  if (str.length > 0) {\n    return str.trim().replace(str[0], str[0].toLowerCase())\n  }\n  return ''\n}\n\nexport function keysToRecord<T extends readonly string[], R = any>(\n  keys: T,\n  func: (key: T[number]) => R\n): { [key in T[number]]: R } {\n  const obj = {} as { [key in T[number]]: R }\n  for (const key of keys) {\n    obj[key as T[number]] = func(key)\n  }\n  return obj\n}\n\nexport function randomId(length = 8) {\n  const dict = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  let id = ''\n  while (length--) {\n    const idx = parseInt((Math.random() * dict.length).toFixed(0), 10) % dict.length\n    id += dict[idx]\n  }\n  return id\n}\n","import { pauseTracking, resetTracking } from '@vue/reactivity'\nimport { isFunction, isPromise } from './utils'\nimport type { Instance } from './instance'\nimport type { Method } from './types'\nimport { getCurrentInstance } from '.'\n\nexport const enum ErrorCodes {\n  SETUP_FUNCTION,\n  RENDER_FUNCTION,\n  WATCH_GETTER,\n  WATCH_CALLBACK,\n  WATCH_CLEANUP,\n  NATIVE_EVENT_HANDLER,\n  COMPONENT_EVENT_HANDLER,\n  APP_ERROR_HANDLER,\n  APP_WARN_HANDLER,\n  FUNCTION_REF,\n  SCHEDULER,\n  NEXT_TICK_FUNCTION,\n}\n\nexport const ErrorTypeStrings: Record<number | string, string> = {\n  [ErrorCodes.SETUP_FUNCTION]: 'setup function',\n  [ErrorCodes.RENDER_FUNCTION]: 'render function',\n  [ErrorCodes.WATCH_GETTER]: 'watcher getter',\n  [ErrorCodes.WATCH_CALLBACK]: 'watcher callback',\n  [ErrorCodes.WATCH_CLEANUP]: 'watcher cleanup function',\n  [ErrorCodes.NATIVE_EVENT_HANDLER]: 'native event handler',\n  [ErrorCodes.COMPONENT_EVENT_HANDLER]: 'component event handler',\n  [ErrorCodes.APP_ERROR_HANDLER]: 'app errorHandler',\n  [ErrorCodes.APP_WARN_HANDLER]: 'app warnHandler',\n  [ErrorCodes.FUNCTION_REF]: 'ref function',\n  [ErrorCodes.SCHEDULER]: 'scheduler flush. This is likely a internals bug. ',\n}\n\nexport function error(err: Error, instance?: Instance | null, type?: ErrorCodes) {\n  if (type) {\n    warn(`未处理的错误 ${type} ${instance ? ' [at: ' + instance.is + ']' : ''} `)\n  }\n  err.message = `[core error]: ${err.message}`\n  if (instance) {\n    err.message += ` [at: ${instance.is}]`\n  }\n  console.error(err.message)\n}\n\nexport function warn(msg: string) {\n  pauseTracking()\n  let warnMsg = `[core warn]: ${msg}`\n  const instance = getCurrentInstance()\n  if (instance) {\n    warnMsg = warnMsg + ` [at: ${instance.is}]`\n  }\n  console.warn(warnMsg)\n  resetTracking()\n}\n\nexport function callWithErrorHandling(fn: Function, instance: Instance | null, type: ErrorCodes, args?: unknown[]) {\n  let res\n  try {\n    res = args ? fn(...args) : fn()\n  } catch (err) {\n    handleError(err, instance, type)\n  }\n  return res\n}\n\nexport function callWithAsyncErrorHandling(\n  fn: Method | Method[],\n  instance: Instance | null,\n  type: ErrorCodes,\n  args?: unknown[]\n): any[] {\n  if (isFunction(fn)) {\n    const res = callWithErrorHandling(fn, instance, type, args)\n    if (res && isPromise(res)) {\n      res.catch(err => {\n        handleError(err, instance, type)\n      })\n    }\n    return res\n  }\n\n  const values: any[] = []\n  for (let i = 0; i < fn.length; i++) {\n    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args))\n  }\n  return values\n}\n\nexport function handleError(err: unknown, instance: Instance | null, type: ErrorCodes) {\n  if (instance) {\n    const errorInfo = ErrorTypeStrings[type]\n    // @ts-ignore\n    const appErrorHandler = null\n    if (appErrorHandler) {\n      callWithErrorHandling(appErrorHandler, null, ErrorCodes.APP_ERROR_HANDLER, [err, instance.is, errorInfo])\n      return\n    }\n  }\n  logError(err, type, instance)\n}\n\nfunction logError(err: unknown, type: ErrorCodes, instance: Instance | null) {\n  const info = ErrorTypeStrings[type]\n  warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`)\n  // crash in dev by default so it's more noticeable\n  console.error(err)\n}\n","import { callWithErrorHandling, ErrorCodes, warn } from './errorHandling'\nimport { isArray, NOOP } from './utils'\nimport type { Instance } from './instance'\n// import { ErrorCodes, callWithErrorHandling } from './errorHandling'\n// import { isArray, NOOP } from '@vue/shared'\n// import { ComponentInternalInstance, getComponentName } from './component'\n// import { warn } from './warning'\n\nexport interface SchedulerJob extends Function {\n  id?: number\n  pre?: boolean\n  active?: boolean\n  computed?: boolean\n  /**\n   * Indicates whether the effect is allowed to recursively trigger itself\n   * when managed by the scheduler.\n   *\n   * By default, a job cannot trigger itself because some built-in method calls,\n   * e.g. Array.prototype.push actually performs reads as well (#1740) which\n   * can lead to confusing infinite loops.\n   * The allowed cases are component update functions and watch callbacks.\n   * Component update functions may update child component props, which in turn\n   * trigger flush: \"pre\" watch callbacks that mutates state that the parent\n   * relies on (#1801). Watch callbacks doesn't track its dependencies so if it\n   * triggers itself again, it's likely intentional and it is the user's\n   * responsibility to perform recursive state mutation that eventually\n   * stabilizes (#1727).\n   */\n  allowRecurse?: boolean\n  /**\n   * Attached by renderer.ts when setting up a component's render effect\n   * Used to obtain component information when reporting max recursive updates.\n   * dev only.\n   */\n  ownerInstance?: Instance\n}\n\nexport type SchedulerJobs = SchedulerJob | SchedulerJob[]\n\nlet isFlushing = false\nlet isFlushPending = false\n\nconst queue: SchedulerJob[] = []\nlet flushIndex = 0\n\nconst pendingPostFlushCbs: SchedulerJob[] = []\nlet activePostFlushCbs: SchedulerJob[] | null = null\nlet postFlushIndex = 0\n\nconst resolvedPromise = /*#__PURE__*/ Promise.resolve() as Promise<any>\nlet currentFlushPromise: Promise<void> | null = null\n\nconst RECURSION_LIMIT = 100\ntype CountMap = Map<SchedulerJob, number>\n\nexport function nextTick<T = void>(this: T, fn?: (this: T) => void): Promise<void> {\n  const p = currentFlushPromise || resolvedPromise\n  return fn ? p.then(this ? fn.bind(this) : fn) : p\n}\n\n// #2768\n// Use binary-search to find a suitable position in the queue,\n// so that the queue maintains the increasing order of job's id,\n// which can prevent the job from being skipped and also can avoid repeated patching.\nfunction findInsertionIndex(id: number) {\n  // the start index should be `flushIndex + 1`\n  let start = flushIndex + 1\n  let end = queue.length\n\n  while (start < end) {\n    const middle = (start + end) >>> 1\n    const middleJobId = getId(queue[middle])\n    middleJobId < id ? (start = middle + 1) : (end = middle)\n  }\n\n  return start\n}\n\nexport function queueJob(job: SchedulerJob) {\n  // the dedupe search uses the startIndex argument of Array.includes()\n  // by default the search index includes the current job that is being run\n  // so it cannot recursively trigger itself again.\n  // if the job is a watch() callback, the search will start with a +1 index to\n  // allow it recursively trigger itself - it is the user's responsibility to\n  // ensure it doesn't end up in an infinite loop.\n  if (\n    !queue.length ||\n    !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)\n  ) {\n    if (job.id == null) {\n      queue.push(job)\n    } else {\n      queue.splice(findInsertionIndex(job.id), 0, job)\n    }\n    queueFlush()\n  }\n}\n\nfunction queueFlush() {\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true\n    currentFlushPromise = resolvedPromise.then(flushJobs)\n  }\n}\n\nexport function invalidateJob(job: SchedulerJob) {\n  const i = queue.indexOf(job)\n  if (i > flushIndex) {\n    queue.splice(i, 1)\n  }\n}\n\nexport function queuePostFlushCb(cb: SchedulerJobs) {\n  if (!isArray(cb)) {\n    if (\n      !activePostFlushCbs ||\n      !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)\n    ) {\n      pendingPostFlushCbs.push(cb)\n    }\n  } else {\n    // if cb is an array, it is a component lifecycle hook which can only be\n    // triggered by a job, which is already deduped in the main queue, so\n    // we can skip duplicate check here to improve perf\n    pendingPostFlushCbs.push(...cb)\n  }\n  queueFlush()\n}\n\nexport function flushPreFlushCbs(\n  seen?: CountMap,\n  // if currently flushing, skip the current job itself\n  i = isFlushing ? flushIndex + 1 : 0\n) {\n  // if (__DEV__) {\n  seen = seen || new Map()\n  // }\n  for (; i < queue.length; i++) {\n    const cb = queue[i]\n    if (cb && cb.pre) {\n      if (checkRecursiveUpdates(seen!, cb)) {\n        continue\n      }\n      queue.splice(i, 1)\n      i--\n      cb()\n    }\n  }\n}\n\nexport function flushPostFlushCbs(seen?: CountMap) {\n  if (pendingPostFlushCbs.length) {\n    const deduped = [...new Set(pendingPostFlushCbs)]\n    pendingPostFlushCbs.length = 0\n\n    // #1947 already has active queue, nested flushPostFlushCbs call\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped)\n      return\n    }\n\n    activePostFlushCbs = deduped\n    // if (__DEV__) {\n    seen = seen || new Map()\n    // }\n\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b))\n\n    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n      if (checkRecursiveUpdates(seen!, activePostFlushCbs[postFlushIndex])) {\n        continue\n      }\n      activePostFlushCbs[postFlushIndex]()\n    }\n    activePostFlushCbs = null\n    postFlushIndex = 0\n  }\n}\n\nconst getId = (job: SchedulerJob): number => (job.id == null ? Infinity : job.id)\n\nconst comparator = (a: SchedulerJob, b: SchedulerJob): number => {\n  const diff = getId(a) - getId(b)\n  if (diff === 0) {\n    if (a.pre && !b.pre) return -1\n    if (b.pre && !a.pre) return 1\n  }\n  return diff\n}\n\nfunction flushJobs(seen?: CountMap) {\n  isFlushPending = false\n  isFlushing = true\n  // if (__DEV__) {\n  seen = seen || new Map()\n  // }\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child so its render effect will have smaller\n  //    priority number)\n  // 2. If a component is unmounted during a parent component's update,\n  //    its update can be skipped.\n  queue.sort(comparator)\n\n  // conditional usage of checkRecursiveUpdate must be determined out of\n  // try ... catch block since Rollup by default de-optimizes treeshaking\n  // inside try-catch. This can leave all warning code unshaked. Although\n  // they would get eventually shaken by a minifier like terser, some minifiers\n  // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\n  const check = (job: SchedulerJob) => checkRecursiveUpdates(seen!, job)\n\n  try {\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex]\n      if (job && job.active !== false) {\n        if (check(job)) {\n          continue\n        }\n        // console.log(`running:`, job.id)\n        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER)\n      }\n    }\n  } finally {\n    flushIndex = 0\n    queue.length = 0\n\n    flushPostFlushCbs(seen)\n\n    isFlushing = false\n    currentFlushPromise = null\n    // some postFlushCb queued jobs!\n    // keep flushing until it drains.\n    if (queue.length || pendingPostFlushCbs.length) {\n      flushJobs(seen)\n    }\n  }\n}\n\nfunction checkRecursiveUpdates(seen: CountMap, fn: SchedulerJob) {\n  if (!seen.has(fn)) {\n    seen.set(fn, 1)\n  } else {\n    const count = seen.get(fn)!\n    if (count > RECURSION_LIMIT) {\n      const instance = fn.ownerInstance\n      const componentName = instance && instance.is\n      warn(\n        `Maximum recursive updates exceeded${\n          componentName ? ` in component <${componentName}>` : ``\n        }. ` +\n          `This means you have a reactive effect that is mutating its own ` +\n          `dependencies and thus recursively triggering itself. Possible sources ` +\n          `include component template, render function, updated hook or ` +\n          `watcher source function.`\n      )\n      return true\n    } else {\n      seen.set(fn, count + 1)\n    }\n  }\n}\n","import { EffectScope, shallowReactive, type ShallowReactive } from '@vue/reactivity'\nimport { APP_LIFETIMES, CORE_KEY, PAGE_LIFETIMES, COMPONENT_LIFETIMES } from './constants'\nimport type { Data, Flat, Method } from './types'\nimport { keysToRecord } from './utils'\n\nexport type InstanceType = 'App' | 'Page' | 'Component'\n\nexport type AppLifetimeKey = typeof APP_LIFETIMES[number]\nexport type PageLifetimeKey = typeof PAGE_LIFETIMES[number]\n\nexport type ComponentPageLifetimeKey = typeof COMPONENT_LIFETIMES.PAGELIFETIMES[number]\nexport type ComponentLifetimeKey =\n  | typeof COMPONENT_LIFETIMES.LIFETIMES[number]\n  | typeof COMPONENT_LIFETIMES.PAGELIFETIMES[number]\n\nexport type AppHooks = { [key in AppLifetimeKey]?: Method[] }\nexport type PageHooks = { [key in PageLifetimeKey]?: Method[] }\nexport type ComponentHooks = { [key in ComponentLifetimeKey]?: Method[] }\n\nexport type Core = {\n  uid: number\n  type: InstanceType\n  props: ShallowReactive<Record<string, any>>\n  hooks: AppHooks & PageHooks & ComponentHooks\n  isUnmounted: boolean\n  scope: EffectScope\n  bindings: Record<string, any>\n  renderCbs: Array<() => void>\n  initHooks(): Core\n  toJSON(): string\n}\n\ntype InstanceCore = {\n  [CORE_KEY]: Core\n  $nextTick: (fn: () => void) => void\n}\n\ntype BaseInstance<D extends Record<string, any>, C, P extends boolean = false> = Flat<\n  WechatMiniprogram.Component.Instance<\n    D,\n    {},\n    {},\n    InstanceCore & {\n      route?: string\n    } & C,\n    P\n  >\n>\n\nexport interface AppCustomProperties {}\nexport interface PageCustomProperties {}\nexport interface ComponentCustomProperties {}\n\nexport type AppInstance = WechatMiniprogram.App.Instance<InstanceCore & AppCustomProperties>\n\nexport type PageInstance = BaseInstance<Data, PageCustomProperties, true>\n\nexport type ComponentInstance = BaseInstance<Data, ComponentCustomProperties, false>\n\nlet currentInstance: PageInstance | ComponentInstance | null = null\n\nexport type Instance = PageInstance | ComponentInstance\n\nexport function setCurrentInstance(instance: Instance) {\n  if (instance) {\n    // @ts-ignore\n    instance[CORE_KEY].scope.on()\n    currentInstance = instance\n  }\n}\nexport function unsetCurrentInstance() {\n  if (currentInstance) {\n    // @ts-ignore\n    currentInstance[CORE_KEY].scope.off()\n    currentInstance = null\n  }\n}\n\nexport function getCurrentInstance() {\n  return currentInstance\n}\n\nlet uid = 0\nexport function createCore(type: InstanceType): Core {\n  const core: Core = {\n    uid: uid++,\n    type: type,\n    props: shallowReactive<Record<string, any>>({}),\n    hooks: {},\n    isUnmounted: false,\n    scope: new EffectScope(),\n    bindings: {},\n    renderCbs: [],\n    initHooks() {\n      switch (this.type) {\n        case 'App':\n          this.hooks = keysToRecord(APP_LIFETIMES, () => [])\n          break\n        case 'Page':\n          this.hooks = keysToRecord(PAGE_LIFETIMES, () => [])\n          break\n        default:\n          this.hooks = keysToRecord(\n            [...COMPONENT_LIFETIMES.LIFETIMES, ...COMPONENT_LIFETIMES.PAGELIFETIMES],\n            () => []\n          )\n          break\n      }\n      return this\n    },\n    toJSON() {\n      return 'core'\n    },\n  }\n\n  return core\n}\n","import {\n  type ComputedRef,\n  type DebuggerOptions,\n  type EffectScheduler,\n  isReactive,\n  isRef,\n  isShallow,\n  ReactiveEffect,\n  type Ref,\n} from '@vue/reactivity'\nimport { queueJob, queuePostFlushCb, type SchedulerJob } from './scheduler'\nimport { getCurrentInstance } from './instance'\nimport {\n  callWithAsyncErrorHandling,\n  callWithErrorHandling,\n  ErrorCodes,\n  warn,\n} from './errorHandling'\nimport {\n  EMPTY_OBJ,\n  hasChanged,\n  isArray,\n  isFunction,\n  isMap,\n  isObject,\n  isPlainObject,\n  isSet,\n  NOOP,\n  remove,\n} from './utils'\nimport { CORE_KEY } from './constants'\n\nexport type WatchEffect = (onCleanup: OnCleanup) => void\n\nexport type WatchSource<T = any> = Ref<T> | ComputedRef<T> | (() => T)\n\nexport type WatchCallback<V = any, OV = any> = (value: V, oldValue: OV, onCleanup: OnCleanup) => any\n\ntype MapSources<T, Immediate> = {\n  [K in keyof T]: T[K] extends WatchSource<infer V>\n    ? Immediate extends true\n      ? V | undefined\n      : V\n    : T[K] extends object\n    ? Immediate extends true\n      ? T[K] | undefined\n      : T[K]\n    : never\n}\n\ntype OnCleanup = (cleanupFn: () => void) => void\n\nexport interface WatchOptionsBase extends DebuggerOptions {\n  flush?: 'pre' | 'post' | 'sync'\n}\n\nexport interface WatchOptions<Immediate = boolean> extends WatchOptionsBase {\n  immediate?: Immediate\n  deep?: boolean\n}\n\nexport type WatchStopHandle = () => void\n\n// Simple effect.\nexport function watchEffect(effect: WatchEffect, options?: WatchOptionsBase): WatchStopHandle {\n  return doWatch(effect, null, options)\n}\n\nexport function watchPostEffect(effect: WatchEffect, options?: DebuggerOptions) {\n  return doWatch(effect, null, { ...options, flush: 'post' })\n}\n\nexport function watchSyncEffect(effect: WatchEffect, options?: DebuggerOptions) {\n  return doWatch(effect, null, { ...options, flush: 'sync' })\n}\n\n// initial value for watchers to trigger on undefined initial values\nconst INITIAL_WATCHER_VALUE = {}\n\ntype MultiWatchSources = (WatchSource<unknown> | object)[]\n\n// overload: array of multiple sources + cb\nexport function watch<T extends MultiWatchSources, Immediate extends Readonly<boolean> = false>(\n  sources: [...T],\n  cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>,\n  options?: WatchOptions<Immediate>\n): WatchStopHandle\n\n// overload: multiple sources w/ `as const`\n// watch([foo, bar] as const, () => {})\n// somehow [...T] breaks when the type is readonly\nexport function watch<\n  T extends Readonly<MultiWatchSources>,\n  Immediate extends Readonly<boolean> = false\n>(\n  source: T,\n  cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>,\n  options?: WatchOptions<Immediate>\n): WatchStopHandle\n\n// overload: single source + cb\nexport function watch<T, Immediate extends Readonly<boolean> = false>(\n  source: WatchSource<T>,\n  cb: WatchCallback<T, Immediate extends true ? T | undefined : T>,\n  options?: WatchOptions<Immediate>\n): WatchStopHandle\n\n// overload: watching reactive object w/ cb\nexport function watch<T extends object, Immediate extends Readonly<boolean> = false>(\n  source: T,\n  cb: WatchCallback<T, Immediate extends true ? T | undefined : T>,\n  options?: WatchOptions<Immediate>\n): WatchStopHandle\n\n// implementation\nexport function watch<T = any, Immediate extends Readonly<boolean> = false>(\n  source: T | WatchSource<T>,\n  cb: any,\n  options?: WatchOptions<Immediate>\n): WatchStopHandle {\n  if (!isFunction(cb)) {\n    warn(\n      `\\`watch(fn, options?)\\` signature has been moved to a separate API. ` +\n        `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` +\n        `supports \\`watch(source, cb, options?) signature.`\n    )\n  }\n  return doWatch(source as any, cb, options)\n}\n\nfunction doWatch(\n  source: WatchSource | WatchSource[] | WatchEffect | object,\n  cb: WatchCallback | null,\n  { immediate, deep, flush, onTrack, onTrigger }: WatchOptions = EMPTY_OBJ\n): WatchStopHandle {\n  if (!cb) {\n    if (immediate !== undefined) {\n      warn(\n        `watch() \"immediate\" option is only respected when using the ` +\n          `watch(source, callback, options?) signature.`\n      )\n    }\n    if (deep !== undefined) {\n      warn(\n        `watch() \"deep\" option is only respected when using the ` +\n          `watch(source, callback, options?) signature.`\n      )\n    }\n  }\n\n  const warnInvalidSource = (s: unknown) => {\n    warn(\n      `Invalid watch source: ${s} \n      A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`\n    )\n  }\n\n  const instance = getCurrentInstance()\n  let getter: () => any\n  let forceTrigger = false\n  let isMultiSource = false\n\n  if (isRef(source)) {\n    getter = () => source.value\n    forceTrigger = isShallow(source)\n  } else if (isReactive(source)) {\n    getter = () => source\n    deep = true\n  } else if (isArray(source)) {\n    isMultiSource = true\n    forceTrigger = source.some(s => isReactive(s) || isShallow(s))\n    getter = () =>\n      source.map(s => {\n        if (isRef(s)) {\n          return s.value\n        } else if (isReactive(s)) {\n          return traverse(s)\n        } else if (isFunction(s)) {\n          return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER)\n        } else {\n          warnInvalidSource(s)\n        }\n      })\n  } else if (isFunction(source)) {\n    if (cb) {\n      // getter with cb\n      getter = () => callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)\n    } else {\n      // no cb -> simple effect\n      getter = () => {\n        if (instance && instance[CORE_KEY].isUnmounted) {\n          return\n        }\n        if (cleanup) {\n          cleanup()\n        }\n        return callWithAsyncErrorHandling(source, instance, ErrorCodes.WATCH_CALLBACK, [onCleanup])\n      }\n    }\n  } else {\n    getter = NOOP\n    warnInvalidSource(source)\n  }\n\n  if (cb && deep) {\n    const baseGetter = getter\n    getter = () => traverse(baseGetter())\n  }\n\n  let cleanup: () => void\n  const onCleanup: OnCleanup = (fn: () => void) => {\n    cleanup = effect.onStop = () => {\n      callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP)\n    }\n  }\n\n  let oldValue: any = isMultiSource\n    ? new Array((source as []).length).fill(INITIAL_WATCHER_VALUE)\n    : INITIAL_WATCHER_VALUE\n  const job: SchedulerJob = () => {\n    if (!effect.active) {\n      return\n    }\n    if (cb) {\n      // watch(source, cb)\n      const newValue = effect.run()\n      if (\n        deep ||\n        forceTrigger ||\n        (isMultiSource\n          ? (newValue as any[]).some((v, i) => hasChanged(v, (oldValue as any[])[i]))\n          : hasChanged(newValue, oldValue))\n      ) {\n        // cleanup before running cb again\n        if (cleanup) {\n          cleanup()\n        }\n        callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [\n          newValue,\n          // pass undefined as the old value when it's changed for the first time\n          oldValue === INITIAL_WATCHER_VALUE\n            ? undefined\n            : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE\n            ? []\n            : oldValue,\n          onCleanup,\n        ])\n        oldValue = newValue\n      }\n    } else {\n      // watchEffect\n      effect.run()\n    }\n  }\n\n  // important: mark the job as a watcher callback so that scheduler knows\n  // it is allowed to self-trigger (#1727)\n  job.allowRecurse = !!cb\n\n  let scheduler: EffectScheduler\n  if (flush === 'sync') {\n    scheduler = job as any // the scheduler function gets called directly\n  } else if (flush === 'post') {\n    scheduler = () => queuePostFlushCb(job)\n  } else {\n    // default: 'pre'\n    job.pre = true\n    if (instance) job.id = instance[CORE_KEY].uid\n    scheduler = () => queueJob(job)\n  }\n\n  const effect = new ReactiveEffect(getter, scheduler)\n\n  // if (__DEV__) {\n  effect.onTrack = onTrack\n  effect.onTrigger = onTrigger\n  // }\n\n  // initial run\n  if (cb) {\n    if (immediate) {\n      job()\n    } else {\n      oldValue = effect.run()\n    }\n  } else if (flush === 'post') {\n    queuePostFlushCb(effect.run.bind(effect))\n  } else {\n    effect.run()\n  }\n\n  const unwatch = () => {\n    effect.stop()\n    if (instance && instance[CORE_KEY].scope) {\n      // @ts-ignore\n      remove(instance[CORE_KEY].scope.effects!, effect)\n    }\n  }\n  return unwatch\n}\n\nexport function createPathGetter(ctx: any, path: string) {\n  const segments = path.split('.')\n  return () => {\n    let cur = ctx\n    for (let i = 0; i < segments.length && cur; i++) {\n      cur = cur[segments[i]]\n    }\n    return cur\n  }\n}\n\nexport function traverse(value: unknown, seen?: Set<unknown>) {\n  if (!isObject(value) || (value as any)['__v_skip']) {\n    return value\n  }\n  seen = seen || new Set()\n  if (seen.has(value)) {\n    return value\n  }\n  seen.add(value)\n  if (isRef(value)) {\n    traverse(value.value, seen)\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], seen)\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach((v: any) => {\n      traverse(v, seen)\n    })\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse((value as any)[key], seen)\n    }\n  }\n  return value\n}\n","import { CORE_KEY, APP_LIFETIMES, COMPONENT_LIFETIMES, PAGE_LIFETIMES } from './constants'\nimport { error } from './errorHandling'\nimport type {\n  AppHooks,\n  AppLifetimeKey,\n  ComponentHooks,\n  ComponentLifetimeKey,\n  Instance,\n  PageHooks,\n  PageLifetimeKey,\n} from './instance'\nimport { getCurrentInstance } from './instance'\nimport type { Method } from './types'\nimport { keysToRecord } from './utils'\n\ntype HookTarget = { App?: AppLifetimeKey; Page?: PageLifetimeKey; Component?: ComponentLifetimeKey }\n\ntype LifetimeKey = AppLifetimeKey | PageLifetimeKey | ComponentLifetimeKey\n\nconst isAppHook = (key: string): key is AppLifetimeKey => APP_LIFETIMES.indexOf(key as any) >= 0\n\nconst isPageHook = (key: string): key is PageLifetimeKey => PAGE_LIFETIMES.indexOf(key as any) >= 0\n\nconst isComponentHook = (key: string): key is ComponentLifetimeKey =>\n  COMPONENT_LIFETIMES['LIFETIMES'].indexOf(key as any) >= 0 ||\n  COMPONENT_LIFETIMES['PAGELIFETIMES'].indexOf(key as any) >= 0\n\n// const isComponentPageHook = (key: string): key is ComponentPageLifetimeKey =>\n//   COMPONENT_LIFETIMES['PAGELIFETIMES'].indexOf(key as any) >= 0\n\nexport type WrapOptions<T> = {\n  lifetimes: T\n  originLifetime: Record<string, any>\n  excludes?: string[]\n}\n\nexport function wrapLifetimeHooks<T extends readonly string[]>(\n  lifetimes: T,\n  excludes: string[] = []\n): { [key in T[number]]: Method } {\n  const list = lifetimes.filter(name => excludes.indexOf(name) === -1) as unknown as T\n  const lifeTimes = keysToRecord<T, Method>(list, key => {\n    return function (this: Instance, ...args: unknown[]) {\n      const hooksGroup = this[CORE_KEY].hooks as any\n      const hooks: Method[] = [...hooksGroup[key]]\n\n      let ret: unknown = undefined\n      hooks.forEach(func => {\n        ret = func(...args)\n      })\n      return ret\n    }\n  })\n  return lifeTimes\n}\n\nfunction getLifetimeHooks(ins: Instance, key: LifetimeKey) {\n  const { type, hooks } = ins[CORE_KEY]\n  if (type === 'App' && isAppHook(key)) {\n    return (hooks as AppHooks)[key]\n  } else if (type === 'Page' && isPageHook(key)) {\n    return (hooks as PageHooks)[key]\n  } else if (type === 'Component' && isComponentHook(key)) {\n    return (hooks as ComponentHooks)[key]\n  }\n  return undefined\n}\n\nfunction createHook<T extends Method>(\n  hook: HookTarget,\n  validator: (ins: Instance, lifetime: string) => boolean = () => true\n) {\n  const { App: appHook, Page: pageHook, Component: componentHook } = hook\n  const firstKey = (appHook || pageHook || componentHook) as LifetimeKey\n\n  return (cb: T) => {\n    const ins = getCurrentInstance()\n    if (!ins) {\n      throw new Error(`当前没有实例 无法调用 ${firstKey} 钩子.`)\n    }\n    const type = ins[CORE_KEY].type\n    const key: LifetimeKey = hook[type]! || firstKey\n\n    const hooks = getLifetimeHooks(ins, key)\n\n    if (!validator(ins, key)) {\n      return\n    }\n\n    if (Array.isArray(hooks)) {\n      hooks.push(cb)\n    } else {\n      error(new Error(`${type} 不存在 ${key} 钩子.`), ins)\n    }\n  }\n}\n\n/**\n * ====== App Lifetime ====\n */\ntype IAppLt = Required<WechatMiniprogram.App.Option>\nexport const onAppShow = createHook<IAppLt['onShow']>({ App: 'onShow' })\nexport const onAppHide = createHook<IAppLt['onHide']>({ App: 'onHide' })\nexport const onError = createHook<IAppLt['onError']>({ App: 'onError', Component: 'error' })\nexport const onPageNotFound = createHook<IAppLt['onPageNotFound']>({ App: 'onPageNotFound' })\nexport const onUnhandledRejection = createHook<IAppLt['onUnhandledRejection']>({ App: 'onUnhandledRejection' })\nexport const onThemeChange = createHook<IAppLt['onThemeChange']>({ App: 'onThemeChange' })\n\n/**\n * ====== Page Lifetime  ====\n */\ntype IPageLt = Required<WechatMiniprogram.Page.ILifetime>\nexport const onLoad = createHook<IPageLt['onLoad']>({ Page: 'onLoad' })\nexport const onUnload = createHook<IPageLt['onUnload']>({ Page: 'onUnload' })\nexport const onPullDownRefresh = createHook<IPageLt['onPullDownRefresh']>({ Page: 'onPullDownRefresh' })\nexport const onReachBottom = createHook<IPageLt['onReachBottom']>({ Page: 'onReachBottom' })\nexport const onAddToFavorites = createHook<IPageLt['onAddToFavorites']>({ Page: 'onAddToFavorites' })\nexport const onTabItemTap = createHook<IPageLt['onTabItemTap']>({ Page: 'onTabItemTap' })\nexport const onSaveExitState = createHook<() => { data: any; expireTimeStamp: number }>({ Page: 'onSaveExitState' })\nexport const onShareAppMessage = createHook<IPageLt['onShareAppMessage']>({ Page: 'onShareAppMessage' })\nexport const onShareTimeline = createHook<IPageLt['onShareTimeline']>({ Page: 'onShareTimeline' })\nexport const onPageScroll = createHook<IPageLt['onPageScroll']>({ Page: 'onPageScroll' })\n\n/**\n * ====== Component Lifetime  ====\n */\ntype CLt = Required<WechatMiniprogram.Component.Lifetimes['lifetimes']>\n// created、attached 没有\nexport const onMoved = createHook<CLt['moved']>({ Component: 'moved' })\nexport const onDetached = createHook<CLt['detached']>({ Component: 'detached' })\n// export const onError = createHook<CLt['error']>({ Component: 'error' })\nexport const onReady = createHook<CLt['ready']>({ Page: 'onReady', Component: 'ready' })\n\n/**\n * ====== Component PageLifetime  ====\n */\ntype CPageLt = Required<WechatMiniprogram.Component.PageLifetimes>\nexport const onShow = createHook<CPageLt['show']>({ Page: 'onShow', Component: 'show' })\nexport const onHide = createHook<CPageLt['hide']>({ Page: 'onHide', Component: 'hide' })\nexport const onResize = createHook<CPageLt['resize']>({ Page: 'onResize', Component: 'resize' })\n","import type { ComponentBaseOptions } from './component'\nimport type { Bindings } from './types'\nimport type { Instance } from './instance'\nimport type { PageBaseOptions } from './page'\nimport { warn } from './errorHandling'\n\nexport type PluginConfig = (options: ComponentBaseOptions) => void\n\nexport type NormalSetup = (props: Record<string, any>, ctx: Instance) => void | Bindings\nexport type ComposeSetup = (\n  props: Record<string, any>,\n  ctx: Instance,\n  next: () => void | Bindings\n) => void | Bindings\n\nexport type PluginSetup = NormalSetup | ComposeSetup\n\nexport type Plugin = {\n  name: string\n  type?: 'Page' | 'Component'\n  config?: PluginConfig\n  setup?: PluginSetup\n}\n\n/**\n * 插件存储\n */\nconst globalPlugins = new Set<Plugin>()\n\nfunction isSerialSetup(setup: PluginSetup): setup is NormalSetup {\n  return setup.length <= 2\n}\nexport function compose(setupGroup: PluginSetup[], props: Record<string, any>, ctx: any) {\n  return function (next: NormalSetup): void | AnyObject {\n    let index = -1\n\n    function dispatch(i: number): void | AnyObject {\n      if (i <= index) {\n        throw new Error('next() called multiple times')\n      }\n      if (i === setupGroup.length) {\n        return next(props, ctx)\n      }\n\n      index = i\n      const setup = setupGroup[i]\n      if (!setup) return undefined\n\n      if (isSerialSetup(setup)) {\n        const bindings = setup(props, ctx)\n        return { ...bindings, ...dispatch(i + 1) }\n      } else {\n        let prev: void | Bindings = {}\n        const curr = setup(props, ctx, () => {\n          prev = dispatch(i + 1)\n          return prev\n        })\n        return curr || prev\n      }\n    }\n\n    return dispatch(0)\n  }\n}\n\nexport function registerPlugins(plugins: Plugin[]) {\n  for (const plugin of plugins) {\n    if (globalPlugins.has(plugin)) {\n      warn(`中间件 ${plugin.name} 重复注册`)\n    } else {\n      globalPlugins.add(plugin)\n    }\n  }\n}\n\nexport function loadPlugin<T extends ComponentBaseOptions | PageBaseOptions>(\n  originOptions: T & { properties?: any },\n  type: 'Page' | 'Component'\n) {\n  const { setup: originSetup = () => {} } = originOptions\n\n  const setupGroup: PluginSetup[] = []\n\n  const installedPlugins = [...globalPlugins].filter(plugin =>\n    plugin.type ? plugin.type === type : true\n  )\n\n  for (const plugin of installedPlugins) {\n    const { type: _type, config, setup } = plugin || {}\n    const pluginType = _type ? [_type] : ['Page', 'Component']\n\n    if (pluginType.indexOf(type) !== -1) {\n      if (config) {\n        config(originOptions as any)\n      }\n      if (setup) {\n        setupGroup.push(setup)\n      }\n    }\n  }\n\n  function setup(props: any, ctx: any) {\n    const setup = compose(setupGroup, props, ctx)\n    return setup(originSetup as NormalSetup)\n  }\n\n  return {\n    options: originOptions as Omit<T, 'setup'>,\n    setup,\n  }\n}\n","import { CORE_KEY } from '../constants'\nimport type { Plugin } from '../plugin'\nimport { remove } from '../utils'\n\n/**\n * 内置中间件 隐藏分享菜单\n * 框架默认会申明 shareAppMessage 和 shareTimeline, 如用户没有调用 onShareAppMessage、onShareTimeline 则需要将菜单隐藏掉。\n */\nexport const SharePlugin: Plugin = {\n  name: 'builtin-share',\n  type: 'Page',\n  setup: (props, ctx, next) => {\n    const menus: any[] = ['shareAppMessage', 'shareTimeline']\n    next()\n    const { onShareAppMessage, onShareTimeline } = ctx[CORE_KEY].hooks\n    if (onShareAppMessage && onShareAppMessage.length > 0) {\n      remove(menus, 'shareAppMessage')\n    }\n    if (onShareTimeline && onShareTimeline.length > 0) {\n      remove(menus, 'shareTimeline')\n    }\n    if (menus.length > 0) {\n      wx.hideShareMenu({\n        menus,\n      })\n    }\n  },\n}\n","import { createCore, setCurrentInstance, unsetCurrentInstance, type Instance } from './instance'\nimport type { Bindings } from './types'\nimport { APP_LIFETIMES, CORE_KEY } from './constants'\nimport { wrapLifetimeHooks } from './lifetimes'\nimport { registerPlugins, type Plugin } from './plugin'\nimport { SharePlugin } from './plugins'\n\nexport type AppOptions = {\n  plugins?: Plugin[]\n  setup: (options: WechatMiniprogram.App.LaunchShowOption, ctx: any) => Bindings | void\n}\n\nexport function createApp(options: AppOptions) {\n  const { setup, plugins = [] } = options\n  registerPlugins([...plugins, SharePlugin])\n\n  const lifetimes = wrapLifetimeHooks(APP_LIFETIMES)\n  const core = createCore('App').initHooks()\n\n  return App({\n    [CORE_KEY]: core,\n    ...lifetimes,\n    onLaunch(...args) {\n      setCurrentInstance({ [CORE_KEY]: core } as unknown as Instance)\n      const bindings = setup(...args, this) || {}\n      unsetCurrentInstance()\n      for (const key of Object.keys(bindings)) {\n        // @ts-ignore\n        this[key] = bindings[key]\n      }\n    },\n  })\n}\n","import type { Data, IfAny } from './types'\nimport { isPlainObject } from './utils'\n\ntype PropMethod<T, TConstructor = any> = [T] extends [((...args: any) => any) | undefined] // if is function with args, allowing non-required functions\n  ? { new (): TConstructor; (): T; readonly prototype: TConstructor } // Create Function like constructor\n  : never\n\ntype PropConstructor<T = any> = { new (...args: any[]): T & {} } | { (): T } | PropMethod<T>\n\nexport type PropType<T> = PropConstructor<T> | PropConstructor<T>[]\n\nexport interface PropOptions<T = any, D = T> {\n  type?: PropType<T> | true | null\n  value?: D\n}\n\nexport type Prop<T, D = T> = PropOptions<T, D> | PropType<T>\n\nexport type NormalizedProps = Record<string, PropOptions>\n\nexport type ComponentObjectPropsOptions<P = Data> = {\n  [K in keyof P]: Prop<P[K]> | null\n}\n\nexport type ComponentPropsOptions<P = Data> = string[] | ComponentObjectPropsOptions<P>\n\ntype RequiredKeys<T> = {\n  [K in keyof T]: T[K] extends\n    | { value: any }\n    // don't mark Boolean props as undefined\n    | BooleanConstructor\n    | { type: BooleanConstructor }\n    ? T[K] extends { value: undefined }\n      ? never\n      : K\n    : never\n}[keyof T]\n\ntype OptionalKeys<T> = Exclude<keyof T, RequiredKeys<T>>\n\ntype InferPropType<T> = [T] extends [null]\n  ? any // null & true would fail to infer\n  : [T] extends [{ type: null | true }]\n  ? any // As TS issue https://github.com/Microsoft/TypeScript/issues/14829 // somehow `ObjectConstructor` when inferred from { (): T } becomes `any` // `BooleanConstructor` when inferred from PropConstructor(with PropMethod) becomes `Boolean`\n  : [T] extends [ObjectConstructor | { type: ObjectConstructor }]\n  ? Record<string, any>\n  : [T] extends [BooleanConstructor | { type: BooleanConstructor }]\n  ? boolean\n  : [T] extends [(infer U)[] | { type: (infer U)[] }]\n  ? InferPropType<U>\n  : [T] extends [Prop<infer V, infer D>]\n  ? unknown extends V\n    ? IfAny<V, V, D>\n    : V\n  : T\n\nexport type ExtractPropTypes<O> = {\n  [K in keyof Pick<O, RequiredKeys<O>>]: InferPropType<O[K]>\n} & {\n  [K in keyof Pick<O, OptionalKeys<O>>]?: InferPropType<O[K]>\n}\n\nexport function convertProps(props: ComponentPropsOptions) {\n  const properties: Record<string, any> = {}\n  if (Array.isArray(props)) {\n    props.forEach(prop => {\n      properties[prop] = {\n        type: null,\n      }\n    })\n  } else {\n    Object.keys(props).forEach(key => {\n      const prop = props[key]\n      if (Array.isArray(prop)) {\n        const [t, ...ts] = prop\n        properties[key] = {\n          type: [t],\n          optionalTypes: ts,\n        }\n      } else if (isPlainObject(prop)) {\n        const _prop: any = { ...prop }\n        if (Array.isArray(prop.type)) {\n          const [t, ...ts] = prop.type\n          _prop.type = t\n          _prop.optionalTypes = ts\n        }\n        properties[key] = _prop\n      } else {\n        properties[key] = {\n          type: prop,\n        }\n      }\n    })\n  }\n\n  return properties\n}\n","import { isArray, getType as toTypeString } from './utils'\n\nconst diffData = (from: any, to: any, data: any = {}, parentKey = '') => {\n  if (from === to) return\n\n  if (from === null || to === null) {\n    // 新旧数据如果存在值为null则添加到需要更新的数据中\n    data[parentKey] = to\n  } else if (toTypeString(from) !== toTypeString(to)) {\n    // 新旧数据如果类型不一样则添加到需要更新的数据中\n    data[parentKey] = to\n  } else if (isArray(to)) {\n    // 如果新旧数据均为数组，则进行diff\n    if (from.length === to.length) {\n      for (let i = 0, len = to.length; i < len; i++) {\n        // 递归处理，处理数据中包含数据或者包含对象的情况\n        diffData(from[i], to[i], data, parentKey + '[' + i + ']')\n      }\n    } else {\n      // 数组长度不一样直接setData\n      data[parentKey] = to\n    }\n  } else if (typeof to === 'object') {\n    // 如果新旧数据均为对象，进行diff\n    const oldKeys = Object.keys(from)\n    const newKeys = Object.keys(to)\n\n    const shouldReplace = oldKeys.some(key => {\n      return (\n        // 因为小程序不支持 undefined , 在新值有 undefined 时，应该直接更新上层对象。\n        (to[key] === undefined && from[key] !== undefined) ||\n        // 新对象缺少旧属性\n        newKeys.indexOf(key) === -1 ||\n        // 新属性和比旧属性少\n        oldKeys.length > newKeys.length\n      )\n    })\n\n    if (!shouldReplace) {\n      newKeys.forEach(key => {\n        const itemKey = parentKey ? parentKey + '.' + key : key\n        const fromItem = from[key]\n        const toItem = to[key]\n        if (\n          fromItem &&\n          toItem &&\n          typeof toItem === 'object' &&\n          toTypeString(from) === toTypeString(to)\n        ) {\n          diffData(fromItem, toItem, data, itemKey)\n          return\n        }\n        if (fromItem !== toItem) {\n          data[itemKey] = toItem\n        }\n      })\n    } else {\n      if (parentKey) {\n        data[parentKey] = to\n      } else {\n        Object.assign(data, to)\n      }\n    }\n  } else {\n    data[parentKey] = to\n  }\n}\n\nexport const diff = function (oldData: any, newData: any) {\n  const target = {}\n  diffData(oldData, newData, target, '')\n  return target\n}\n","import { isReactive, isRef, reactive, toRaw, unref, type Ref } from '@vue/reactivity'\nimport { CORE_KEY } from './constants'\nimport { diff } from './diff'\nimport { error } from './errorHandling'\nimport type { Instance } from './instance'\nimport type { Method } from './types'\nimport { isArray, isFunction, isJsonBaseType, isPlainObject, getType } from './utils'\nimport { watch } from './watch'\n\nexport function watchData<T extends object = Record<string, any>>(\n  bindings: T,\n  ctx: Instance,\n  cb?: Method\n) {\n  let prevData = toDataRaw(bindings, 'data')\n  return watch(\n    bindings,\n    () => {\n      const currData = toDataRaw(bindings, 'data')\n      const patchData = diff(prevData, currData)\n      if (Object.keys(patchData).length > 0) {\n        ctx.setData(patchData, cb)\n        prevData = currData\n      }\n    },\n    {\n      deep: true,\n    }\n  )\n}\n\nexport function toDataRaw(x: any, key?: string): any {\n  if (typeof x === 'object') {\n    if (x === null) {\n      return null\n    } else if (isReactive(x)) {\n      return toDataRaw(toRaw(x), key)\n    } else if (isRef(x)) {\n      return toDataRaw((x as Ref<any>).value, key)\n    } else if (Array.isArray(x)) {\n      return (x as any[]).map((item, i) => toDataRaw(item, `${key}[${i}]`))\n    }\n    const obj: Record<string, any> = {}\n    Object.keys(x).forEach(k => {\n      obj[k] = toDataRaw(x[k], `${key}.${k}`)\n    })\n    return obj\n  } else if (isJsonBaseType(x)) {\n    return x\n  } else {\n    error(\n      new Error(\n        `错误的数据类型 ${key}:${getType(\n          x\n        )}, 小程序 data 仅支持可以转成 JSON 的类型(string | number | boolean | object | array)`\n      )\n    )\n    return undefined\n  }\n}\n","import { reactive, shallowReactive, shallowReadonly } from '@vue/reactivity'\nimport { createCore, type Instance, setCurrentInstance, unsetCurrentInstance } from './instance'\nimport { CORE_KEY } from './constants'\nimport type { Data } from './types'\nimport { isFunction } from './utils'\nimport { error, ErrorCodes, warn } from './errorHandling'\nimport { toDataRaw, watchData } from './bindings'\n\ntype CoreSetupOptions = {\n  type: 'Page' | 'Component'\n  properties: Record<string, any>\n  setup?: (...args: any[]) => any\n}\n\nfunction getQueryProxy(params: string[], data: Record<string, any>) {\n  const queryData = params.reduce((prev, param) => {\n    prev[param] = data[param]\n    return prev\n  }, {} as any)\n  const query = new Proxy(queryData, {\n    get(target, prop, receiver) {\n      if (!Reflect.has(target, prop)) {\n        warn(`参数 ${prop.toString()} 未在 \\`properties\\` 中定义`)\n      }\n      return Reflect.get(target, prop, receiver)\n    },\n  })\n  return query\n}\n\nexport const createSetupHook = ({ type, setup, properties = {} }: CoreSetupOptions) => {\n  return {\n    created: function (this: Instance) {\n      this[CORE_KEY] = createCore(type).initHooks()\n    },\n    attached: function (this: Instance) {\n      const ctx = this as Instance\n      const core = ctx[CORE_KEY]\n\n      ctx.$nextTick = fn => {\n        ctx[CORE_KEY].renderCbs.push(fn)\n      }\n      if (core.type === 'Page') {\n        core.props = getQueryProxy(Object.keys(ctx.properties), ctx.data)\n      } else {\n        core.props = Object.keys(properties).reduce((prev, key) => {\n          prev[key] = ctx.data[key]\n          return prev\n        }, shallowReactive<Record<string, any>>({}))\n      }\n\n      const props = core.type === 'Page' ? core.props : (shallowReadonly(core.props) as Data)\n\n      setCurrentInstance(ctx)\n      const bindings: Record<string, any> = setup ? setup.call(ctx, props, ctx) || {} : {}\n      core.bindings = bindings\n\n      if (bindings) {\n        const bindingData: any = reactive({})\n        for (const key of Object.keys(bindings)) {\n          const value = bindings[key]\n          if (isFunction(value)) {\n            // @ts-ignore\n            ctx[key] = value\n          } else {\n            bindingData[key] = value\n          }\n        }\n        ctx.setData(toDataRaw(bindingData, 'data'))\n        watchData(bindingData, ctx, () => {\n          try {\n            const ticks = [...ctx[CORE_KEY].renderCbs]\n            ctx[CORE_KEY].renderCbs = []\n            ticks.forEach(fn => fn())\n          } catch (err) {\n            error(err, ctx, ErrorCodes.NEXT_TICK_FUNCTION)\n          }\n        })\n      }\n      unsetCurrentInstance()\n    },\n  }\n}\n","import type { Instance, PageInstance } from './instance'\nimport type { AnyObject, Flat } from './types'\nimport {\n  convertProps,\n  type ComponentObjectPropsOptions,\n  type ComponentPropsOptions,\n  type ExtractPropTypes,\n} from './props'\nimport { wrapLifetimeHooks } from './lifetimes'\nimport { createSetupHook } from './setup'\nimport { loadPlugin } from './plugin'\nimport type { StyleIsolation } from './component'\nimport { PAGE_LIFETIMES, CORE_KEY } from './constants'\n\nexport type PageStyleIsolation =\n  | StyleIsolation\n  | 'page-isolated'\n  | 'page-apply-shared'\n  | 'page-shared'\n\nexport type PageInnerOptions = {\n  /**\n   * 组件样式隔离\n   */\n  styleIsolation?: PageStyleIsolation\n}\n\nexport type PageBaseOptions<P = {}> = {\n  behaviors?: string[]\n  /**\n   * 一些选项\n   */\n  options?: PageInnerOptions\n  setup?: (props: P, ctx: PageInstance) => AnyObject | void\n}\n\ntype PageOptionsWithoutProps<P = {}> = PageBaseOptions<P> & {\n  properties?: undefined\n}\n\ntype PageOptionsWithArrayProps<\n  PropNames extends string = string,\n  P = Readonly<{ [key in PropNames]?: string }>\n> = PageBaseOptions<P> & {\n  properties: PropNames[]\n}\n\ntype PageOptionsWithObjectProps<\n  PropsOptions = ComponentObjectPropsOptions,\n  P = Readonly<Flat<ExtractPropTypes<PropsOptions>>>\n> = PageBaseOptions<P> & {\n  properties: PropsOptions\n}\n\nexport function definePage<P = {}>(options: PageOptionsWithoutProps<P>): string\nexport function definePage<P extends string>(options: PageOptionsWithArrayProps<P>): string\nexport function definePage<P extends Readonly<ComponentPropsOptions>>(\n  options: PageOptionsWithObjectProps<P>\n): string\nexport function definePage(\n  pageOptions: PageBaseOptions<any> & {\n    properties?: ComponentPropsOptions\n  }\n) {\n  const { setup, options } = loadPlugin(pageOptions, 'Page')\n  const {\n    behaviors = [],\n    properties: propsOptions = {},\n    options: innerOptions,\n    ...others\n  } = options\n\n  const properties = convertProps(propsOptions)\n\n  const { onUnload, ...lifetimes } = wrapLifetimeHooks(PAGE_LIFETIMES)\n\n  const { created, attached } = createSetupHook({ type: 'Page', properties, setup })\n  const sourceOptions = {\n    behaviors: [\n      Behavior({\n        properties,\n        lifetimes: { created },\n      }),\n      ...behaviors,\n      // setup behaviors 在最后执行可以使\n      Behavior({\n        lifetimes: { attached },\n      }),\n    ],\n    options: innerOptions,\n    ...others,\n    ...lifetimes,\n    onUnload(this: Instance) {\n      onUnload.call(this)\n      this[CORE_KEY].isUnmounted = true\n      this[CORE_KEY].scope.stop()\n    },\n  }\n  return Page(sourceOptions) as unknown as string\n}\n","import type { ComponentInstance, Instance } from './instance'\nimport type { ComponentObjectPropsOptions, ComponentPropsOptions, ExtractPropTypes } from './props'\nimport { convertProps } from './props'\nimport type { AnyObject, Flat } from './types'\nimport { COMPONENT_LIFETIMES, CORE_KEY } from './constants'\nimport { keysToRecord } from './utils'\nimport { createSetupHook } from './setup'\nimport { wrapLifetimeHooks } from './lifetimes'\nimport { loadPlugin } from './plugin'\n\nexport type StyleIsolation = 'isolated' | 'apply-shared' | 'shared'\n\nexport type RelationOption = {\n  type: 'parent' | 'child' | 'ancestor' | 'descendant'\n  linked?(target: any): void\n  linkChanged?(target: any): void\n  unlinked?(target: any): void\n  /** 如果这一项被设置，则它表示关联的目标节点所应具有的behavior，所有拥有这一behavior的组件节点都会被关联 */\n  target?: string | undefined\n}\n\nexport type ComponentInnerOptions = {\n  /**\n   * 启用多slot支持\n   */\n  multipleSlots?: boolean\n  /**\n   * 组件样式隔离\n   */\n  styleIsolation?: StyleIsolation\n  /**\n   * 虚拟化组件节点\n   */\n  virtualHost?: boolean\n}\n\nexport type ComponentBaseOptions<P = {}> = {\n  behaviors?: string[]\n  observers?: Record<string, (...args: any[]) => any>\n  externalClasses?: string[]\n  relations?: { [key: string]: RelationOption }\n  options?: ComponentInnerOptions\n  setup?: (this: void, props: P, ctx: ComponentInstance) => AnyObject | void\n}\n\ntype ComponentOptionsWithoutProps<P = {}> = ComponentBaseOptions<P> & {\n  properties?: undefined\n}\n\ntype ComponentOptionsWithArrayProps<\n  PropNames extends string = string,\n  P = Readonly<{ [key in PropNames]?: string }>\n> = ComponentBaseOptions<P> & {\n  properties: PropNames[]\n}\n\ntype ComponentOptionsWithObjectProps<\n  PropsOptions = ComponentObjectPropsOptions,\n  P = Readonly<Flat<ExtractPropTypes<PropsOptions>>>\n> = ComponentBaseOptions<P> & {\n  properties: PropsOptions\n}\n\nexport function defineComponent<P = {}>(options: ComponentOptionsWithoutProps<P>): string\nexport function defineComponent<P extends string>(\n  options: ComponentOptionsWithArrayProps<P>\n): string\nexport function defineComponent<P extends Readonly<ComponentPropsOptions>>(\n  options: ComponentOptionsWithObjectProps<P>\n): string\nexport function defineComponent(\n  componentOptions: ComponentBaseOptions<AnyObject> & {\n    properties?: ComponentPropsOptions\n  }\n) {\n  const { setup, options } = loadPlugin(componentOptions, 'Component')\n\n  const {\n    properties: propsOptions = {},\n    behaviors = [],\n    observers = {},\n    options: innerOptions,\n    externalClasses,\n    relations,\n    ...others\n  } = options\n\n  const properties = convertProps(propsOptions)\n  const propNames = Object.keys(properties)\n  const { detached, ...lifetimes } = wrapLifetimeHooks(COMPONENT_LIFETIMES.LIFETIMES)\n  const pageLifetimes = wrapLifetimeHooks(COMPONENT_LIFETIMES.PAGELIFETIMES)\n\n  const propsObservers = keysToRecord(propNames, propName => {\n    return function (this: ComponentInstance, ...args: unknown[]) {\n      const _props = this[CORE_KEY].props\n      if (_props[propName] !== args[0]) {\n        _props[propName] = args[0]\n      }\n      if (observers[propName]) {\n        observers[propName](...args)\n      }\n    }\n  })\n\n  const { created, attached } = createSetupHook({ type: 'Component', properties, setup })\n  const sourceOptions = {\n    properties,\n    behaviors: behaviors,\n    options: Object.assign({ multipleSlots: true }, innerOptions),\n    externalClasses,\n    relations,\n    ...others,\n    observers: {\n      ...observers,\n      ...propsObservers,\n    },\n    lifetimes: {\n      ...lifetimes,\n      created(this: Instance) {\n        created.call(this)\n        // @ts-ignore\n        lifetimes.created && lifetimes.created.call(this)\n      },\n      attached(this: Instance) {\n        // @ts-ignore\n        attached.call(this)\n        lifetimes.attached && lifetimes.attached.call(this)\n      },\n      detached(this: Instance) {\n        detached.call(this)\n        this[CORE_KEY].isUnmounted = true\n        this[CORE_KEY].scope.stop()\n      },\n    },\n    pageLifetimes,\n    methods: {},\n  }\n  return Component(sourceOptions)\n}\n","import {\n  EffectScope,\n  effectScope,\n  isReactive,\n  isRef,\n  markRaw,\n  reactive,\n  ref,\n  toRaw,\n  toRef,\n  type Ref,\n  type ToRefs,\n  type UnwrapRef,\n} from '@vue/reactivity'\nimport type { Flat, Method, PickKeysByType } from '../types'\nimport { isPlainObject } from '../utils'\n\ntype _DeepPartial<T> = { [K in keyof T]?: _DeepPartial<T[K]> }\n\ntype ActionsTree = Record<string, Method>\n\ntype StateTree = Record<string | number | symbol, any>\n\ntype StoreAction<SS> = Pick<SS, PickKeysByType<SS, Method>>\ntype StoreState<SS> = Omit<SS, PickKeysByType<SS, Method>>\n\nexport type Store<Id extends string = string, S extends StateTree = {}, A /* extends ActionsTree */ = {}> = {\n  $id: Id\n  $state: UnwrapRef<S>\n  $patch(partialState: _DeepPartial<UnwrapRef<S>>): void\n} & UnwrapRef<S> &\n  // StoreWithActions<A> &\n  (ActionsTree extends A ? {} : A)\n\ntype StoreGeneric = Store<string, StateTree, ActionsTree>\n\n/**\n * Return type of `defineStore()`. Function that allows instantiating a store.\n */\nexport type StoreDefinition<Id extends string = string, S extends StateTree = StateTree, A = ActionsTree> = () => Flat<\n  Store<Id, S, A>\n>\n\ntype Pinia = {\n  state: Ref<Record<string, StateTree>>\n  _e: EffectScope\n  _s: Map<string, StoreGeneric>\n}\n\nfunction createRootStore() {\n  const scope = new EffectScope(true)\n  const state = scope.run<Ref<Record<string, StateTree>>>(() => ref<Record<string, StateTree>>({}))!\n  const pinia: Pinia = markRaw({\n    _e: scope,\n    _s: new Map<string, StoreGeneric>(),\n    state,\n  })\n  return pinia\n}\n\nconst rootStore = createRootStore()\n\nexport const resetRootStore = () => {\n  rootStore._e = new EffectScope(true)\n  rootStore._s = new Map<string, StoreGeneric>()\n  rootStore.state = rootStore._e.run<Ref<Record<string, StateTree>>>(() => ref<Record<string, StateTree>>({}))!\n}\n\nfunction mergeReactiveObjects<T extends StateTree>(target: T, patchToApply: _DeepPartial<T>): T {\n  // Handle Map instances\n  if (target instanceof Map && patchToApply instanceof Map) {\n    patchToApply.forEach((value, key) => target.set(key, value))\n  }\n  // Handle Set instances\n  if (target instanceof Set && patchToApply instanceof Set) {\n    patchToApply.forEach(target.add, target)\n  }\n\n  // no need to go through symbols because they cannot be serialized anyway\n  for (const key in patchToApply) {\n    if (!patchToApply.hasOwnProperty(key)) continue\n    const subPatch = patchToApply[key]\n    const targetValue = target[key]\n    if (\n      isPlainObject(targetValue) &&\n      isPlainObject(subPatch) &&\n      target.hasOwnProperty(key) &&\n      !isRef(subPatch) &&\n      !isReactive(subPatch)\n    ) {\n      // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might\n      // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that\n      // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.\n      target[key] = mergeReactiveObjects(targetValue, subPatch)\n    } else {\n      // @ts-ignore\n      target[key] = subPatch\n    }\n  }\n\n  return target\n}\n\nfunction createSetupStore<Id extends string, SS, S extends StateTree, A extends ActionsTree>(\n  $id: Id,\n  setup: () => SS\n): Store<Id, S, A> {\n  let scope!: EffectScope\n\n  rootStore.state.value[$id] = {}\n\n  function $patch(stateMutation: (state: UnwrapRef<S>) => void): void\n  function $patch(partialState: _DeepPartial<UnwrapRef<S>>): void\n  function $patch(partialStateOrMutator: _DeepPartial<UnwrapRef<S>> | ((state: UnwrapRef<S>) => void)): void {\n    if (typeof partialStateOrMutator === 'function') {\n      partialStateOrMutator(rootStore.state.value[$id] as UnwrapRef<S>)\n    } else {\n      mergeReactiveObjects(rootStore.state.value[$id], partialStateOrMutator)\n    }\n  }\n\n  const partialStore = {\n    $id,\n    $patch,\n  }\n\n  const store: Store<Id, S, A> = reactive(\n    Object.assign(\n      {},\n      partialStore\n      // must be added later\n      // setupStore\n    )\n  ) as unknown as Store<Id, S, A>\n\n  // store the partial store now so the setup of stores can instantiate each other before they are finished without\n  // creating infinite loops.\n  rootStore._s.set($id, store)\n\n  // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped\n  const setupStore = rootStore._e.run(() => {\n    scope = effectScope()\n    return scope.run(() => setup())\n  })!\n\n  // overwrite existing actions to support $onAction\n  for (const key in setupStore) {\n    const prop = setupStore[key]\n\n    if (isRef(prop) || isReactive(prop)) {\n      rootStore.state.value[$id][key] = prop\n    } else if (typeof prop === 'function') {\n      setupStore[key] = prop\n    }\n  }\n\n  Object.assign(store, setupStore)\n  // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.\n  // Make `storeToRefs()` work with `reactive()` #799\n  Object.assign(toRaw(store), setupStore)\n\n  // use this instead of a computed with setter to be able to create it anywhere\n  // without linking the computed lifespan to wherever the store is first\n  // created.\n  Object.defineProperty(store, '$state', {\n    get: () => rootStore.state.value[$id],\n    set: state => {\n      $patch($state => {\n        Object.assign($state, state)\n      })\n    },\n  })\n  return store\n}\n\nexport function defineStore<Id extends string, SS>(\n  id: Id,\n  setup: () => SS\n): StoreDefinition<Id, StoreState<SS>, StoreAction<SS>> {\n  function useStore(): Flat<Store<Id, StoreState<SS>, StoreAction<SS>>> {\n    if (!rootStore._s.has(id)) {\n      createSetupStore(id, setup)\n    }\n    const store: StoreGeneric = rootStore._s.get(id)!\n    // StoreGeneric cannot be casted towards Store\n    return store as any\n  }\n\n  useStore.$id = id\n\n  return useStore\n}\n\nexport function storeToRefs<SS extends StoreGeneric>(store: SS): ToRefs<StoreState<SS>> {\n  store = toRaw(store)\n  const refs = {} as ToRefs<StoreState<SS>>\n  for (const key in store) {\n    const value = store[key]\n    if (isRef(value) || isReactive(value)) {\n      // @ts-ignore\n      refs[key] = toRef(store, key)\n    }\n  }\n  return refs\n}\n"],"mappings":"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","names":["src_exports","__export","CORE_KEY","ITERATE_KEY","computed","createApp","customRef","defineComponent","definePage","defineStore","getCurrentInstance","isProxy","isReactive","isReadonly","isRef","isShallow","loadPlugin","markRaw","nextTick","onAddToFavorites","onAppHide","onAppShow","onDetached","onError","onHide","onLoad","onMoved","onPageNotFound","onPageScroll","onPullDownRefresh","onReachBottom","onReady","onResize","onSaveExitState","onShareAppMessage","onShareTimeline","onShow","onTabItemTap","onThemeChange","onUnhandledRejection","onUnload","reactive","readonly","ref","registerPlugins","shallowReactive","shallowReadonly","shallowRef","storeToRefs","toRaw","toRef","toRefs","triggerRef","unref","watch","watchEffect","watchPostEffect","watchSyncEffect","__toCommonJS","CORE_KEY","APP_LIFETIMES","PAGE_LIFETIMES","COMPONENT_LIFETIMES","makeMap","str","expectsLowerCase","map","list","i","val","styleCommentRE","specialBooleanAttrs","isBooleanAttr","makeMap","specialBooleanAttrs","NOOP","extend","hasOwnProperty","hasOwn","val","key","isArray","isMap","toTypeString","isFunction","val","isString","isSymbol","isObject","objectToString","toTypeString","value","toRawType","isIntegerKey","key","isString","cacheStringFunction","fn","cache","str","camelizeRE","camelize","_","c","hyphenateRE","hyphenate","capitalize","toHandlerKey","hasChanged","value","oldValue","def","obj","key","value","activeEffectScope","EffectScope","detached","fn","currentEffectScope","fromParent","i","l","last","effectScope","recordEffectScope","effect","scope","createDep","effects","dep","wasTracked","trackOpBit","newTracked","initDepMarkers","deps","i","finalizeDepMarkers","effect","ptr","targetMap","effectTrackDepth","maxMarkerBits","activeEffect","ITERATE_KEY","MAP_KEY_ITERATE_KEY","ReactiveEffect","fn","scheduler","scope","recordEffectScope","parent","lastShouldTrack","shouldTrack","cleanupEffect","shouldTrack","trackStack","pauseTracking","resetTracking","last","trackStack","shouldTrack","track","target","type","key","activeEffect","depsMap","targetMap","dep","createDep","trackEffects","debuggerEventExtraInfo","effectTrackDepth","maxMarkerBits","newTracked","trackOpBit","wasTracked","trigger","newValue","oldValue","oldTarget","deps","isArray","newLength","isIntegerKey","ITERATE_KEY","isMap","MAP_KEY_ITERATE_KEY","eventInfo","triggerEffects","effects","effect","triggerEffect","getDepFromReactive","object","_a","isNonTrackableKeys","makeMap","builtInSymbols","isSymbol","get$1","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","createArrayInstrumentations","instrumentations","args","arr","toRaw","i","l","res","pauseTracking","hasOwnProperty","obj","isReadonly","shallow","receiver","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","targetIsArray","hasOwn","isRef","isObject","readonly","reactive","set$1","createSetter","shallowSet","value","isShallow","hadKey","result","hasChanged","deleteProperty","has$1","ownKeys","mutableHandlers","readonlyHandlers","shallowReactiveHandlers","extend","shallowReadonlyHandlers","toShallow","getProto","v","get","rawTarget","rawKey","has","wrap","toReadonly","toReactive","size","add","set","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","isKeyOnly","innerIterator","done","createReadonlyMethod","createInstrumentations","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","shallowReadonlyInstrumentations","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","shallowReadonlyCollectionHandlers","reactiveMap","shallowReactiveMap","readonlyMap","shallowReadonlyMap","targetTypeMap","rawType","getTargetType","value","toRawType","reactive","target","isReadonly","createReactiveObject","mutableHandlers","mutableCollectionHandlers","shallowReactive","shallowReactiveHandlers","shallowCollectionHandlers","readonly","readonlyHandlers","readonlyCollectionHandlers","shallowReadonly","shallowReadonlyHandlers","shallowReadonlyCollectionHandlers","baseHandlers","collectionHandlers","proxyMap","isObject","existingProxy","targetType","proxy","isReactive","isShallow","isProxy","toRaw","observed","raw","markRaw","def","toReactive","toReadonly","trackRefValue","ref","shouldTrack","activeEffect","trackEffects","createDep","triggerRefValue","newVal","dep","triggerEffects","isRef","r","createRef","shallowRef","rawValue","shallow","RefImpl","__v_isShallow","useDirectValue","hasChanged","triggerRef","unref","CustomRefImpl","factory","get","set","trackRefValue","triggerRefValue","newVal","customRef","toRefs","object","ret","isArray","key","toRef","ObjectRefImpl","_object","_key","_defaultValue","val","getDepFromReactive","toRaw","defaultValue","isRef","_a$1","ComputedRefImpl","getter","_setter","isReadonly","isSSR","ReactiveEffect","self","newValue","computed","getterOrOptions","debugOptions","setter","onlyGetter","isFunction","NOOP","_a","_a","EMPTY_OBJ","NOOP","getType","value","isArray","isFunction","val","isMap","isSet","isPlainObject","isObject","isPromise","isJsonBaseType","x","hasChanged","value","oldValue","remove","arr","el","i","keysToRecord","keys","func","obj","key","ErrorTypeStrings","error","err","instance","type","warn","msg","pauseTracking","warnMsg","getCurrentInstance","resetTracking","callWithErrorHandling","fn","args","res","handleError","callWithAsyncErrorHandling","isFunction","isPromise","values","i","errorInfo","appErrorHandler","logError","info","isFlushing","isFlushPending","queue","flushIndex","pendingPostFlushCbs","activePostFlushCbs","postFlushIndex","resolvedPromise","currentFlushPromise","RECURSION_LIMIT","nextTick","fn","p","findInsertionIndex","id","start","end","middle","getId","queueJob","job","queueFlush","flushJobs","queuePostFlushCb","cb","isArray","pendingPostFlushCbs","activePostFlushCbs","postFlushIndex","queueFlush","flushPostFlushCbs","seen","pendingPostFlushCbs","deduped","activePostFlushCbs","a","b","getId","postFlushIndex","checkRecursiveUpdates","job","comparator","diff","flushJobs","isFlushPending","isFlushing","queue","check","flushIndex","callWithErrorHandling","currentFlushPromise","fn","count","RECURSION_LIMIT","instance","componentName","warn","currentInstance","setCurrentInstance","instance","CORE_KEY","unsetCurrentInstance","getCurrentInstance","uid","createCore","type","shallowReactive","EffectScope","keysToRecord","APP_LIFETIMES","PAGE_LIFETIMES","COMPONENT_LIFETIMES","watchEffect","effect","options","doWatch","watchPostEffect","__spreadProps","__spreadValues","watchSyncEffect","INITIAL_WATCHER_VALUE","watch","source","cb","isFunction","warn","immediate","deep","flush","onTrack","onTrigger","EMPTY_OBJ","warnInvalidSource","s","instance","getCurrentInstance","getter","forceTrigger","isMultiSource","isRef","isShallow","isReactive","isArray","traverse","callWithErrorHandling","CORE_KEY","cleanup","callWithAsyncErrorHandling","onCleanup","NOOP","baseGetter","fn","oldValue","job","newValue","v","i","hasChanged","scheduler","queuePostFlushCb","queueJob","ReactiveEffect","remove","traverse","value","seen","isObject","isRef","isArray","i","isSet","isMap","v","isPlainObject","key","isAppHook","key","APP_LIFETIMES","isPageHook","PAGE_LIFETIMES","isComponentHook","COMPONENT_LIFETIMES","wrapLifetimeHooks","lifetimes","excludes","list","name","keysToRecord","args","hooks","CORE_KEY","ret","func","getLifetimeHooks","ins","type","createHook","hook","validator","appHook","pageHook","componentHook","firstKey","cb","getCurrentInstance","error","onAppShow","onAppHide","onError","onPageNotFound","onUnhandledRejection","onThemeChange","onLoad","onUnload","onPullDownRefresh","onReachBottom","onAddToFavorites","onTabItemTap","onSaveExitState","onShareAppMessage","onShareTimeline","onPageScroll","onMoved","onDetached","onReady","onShow","onHide","onResize","globalPlugins","isSerialSetup","setup","compose","setupGroup","props","ctx","next","index","dispatch","i","bindings","__spreadValues","prev","registerPlugins","plugins","plugin","warn","loadPlugin","originOptions","type","originSetup","installedPlugins","_type","config","SharePlugin","props","ctx","next","menus","onShareAppMessage","onShareTimeline","CORE_KEY","remove","createApp","options","setup","plugins","registerPlugins","SharePlugin","lifetimes","wrapLifetimeHooks","APP_LIFETIMES","core","createCore","__spreadProps","__spreadValues","CORE_KEY","args","setCurrentInstance","bindings","unsetCurrentInstance","key","convertProps","props","properties","prop","key","t","ts","isPlainObject","_prop","__spreadValues","diffData","from","to","data","parentKey","getType","isArray","i","len","oldKeys","newKeys","key","itemKey","fromItem","toItem","diff","oldData","newData","target","watchData","bindings","ctx","cb","prevData","toDataRaw","watch","currData","patchData","diff","x","key","isReactive","toRaw","isRef","item","i","obj","k","isJsonBaseType","error","getType","getQueryProxy","params","data","queryData","prev","param","target","prop","receiver","warn","createSetupHook","type","setup","properties","CORE_KEY","createCore","ctx","core","fn","key","shallowReactive","props","shallowReadonly","setCurrentInstance","bindings","bindingData","reactive","value","isFunction","toDataRaw","watchData","ticks","err","error","unsetCurrentInstance","definePage","pageOptions","setup","options","loadPlugin","_a","behaviors","propsOptions","innerOptions","others","__objRest","properties","convertProps","_b","wrapLifetimeHooks","PAGE_LIFETIMES","onUnload","lifetimes","created","attached","createSetupHook","sourceOptions","__spreadProps","__spreadValues","CORE_KEY","defineComponent","componentOptions","setup","options","loadPlugin","_a","propsOptions","behaviors","observers","innerOptions","externalClasses","relations","others","__objRest","properties","convertProps","propNames","_b","wrapLifetimeHooks","COMPONENT_LIFETIMES","detached","lifetimes","pageLifetimes","propsObservers","keysToRecord","propName","args","_props","CORE_KEY","created","attached","createSetupHook","sourceOptions","__spreadProps","__spreadValues","createRootStore","scope","EffectScope","state","ref","markRaw","rootStore","mergeReactiveObjects","target","patchToApply","value","key","subPatch","targetValue","isPlainObject","isRef","isReactive","createSetupStore","$id","setup","scope","rootStore","$patch","partialStateOrMutator","store","reactive","setupStore","effectScope","prop","toRaw","state","$state","defineStore","id","useStore","storeToRefs","refs","toRef"]}